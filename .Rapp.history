21.4*.813
21.4 -21.4*.813
library(lubridaste)
library(lubrida=te)
library(lubridate)
-v
install.packages("rgeos", repos="http://R-Forge.R-project.org")#
require(rgeos)
library(rgeos)
require(rgeos)
library(rgeos)
install.packages("rgdal", repos="http://R-Forge.R-project.org")#
require(rgdal)
R CMD INSTALL ~/Downloads/rgdal_0.9-1.tar.gz --configure-args='--with-gdal-config=/Library/Frameworks/GDAL.framework/Programs/gdal-config#
 --with-proj-include=/Library/Frameworks/PROJ.framework/Headers#
 --with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib'
R CMD INSTALL ~/Downloads/rgdal_0.9-1.tar.gz --configure-args='--with-gdal-config=/Library/Frameworks/GDAL.framework/Programs/gdal-config--with-proj-include=/Library/Frameworks/PROJ.framework/Headers--with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib'
library(lme3)
library(lme4)
300/241
.244*30
1.25*300
1.25*240
7*12
7849-7527
322/1353
8028-7527
501/1353
8028-7957
1353-501
852/71
7956-7878
8176-8029
8176-8092
250*.75
250*.25
42*2 + 17*2
118/19
21/6.2
59.5*.75
59.5*.5 + 59.5
71/12
597/80
597/8
432/8
15*8 + 9*3
?seq_len
7.25/3
7.25/4
for(i in 0:9){x=cos(2*pi/10*i);y=x+1;z=(y-2)*22;pie(c(y,8-y),col=c(0,7),init.angl=135-z,bo=F,la=NA)}
install.packages("ProjectTemplate")
install.packages("dplyr")
install.packages("ggplot2")
install.packages("data.table")
install.packages("corrgram")
install.packages("survival")
install.packages("shapefiles")
install.packages("rgdal")
install.packages("PBSmapping")
install.packages("sp")
install.packages("gdistance")
install.packages("chron")
install.packages("unmarked")
install.packages("lme4")
install.packages("rgeos", repos="http://R-Forge.R-project.org", type="source")#
require(rgeos)
install.packages('rgdal',repos="http://www.stats.ox.ac.uk/pub/RWin")
library(rgdal)
install.packages("http://cran.r-project.org/src/contrib/rgdal_0.9-1.tar.gz", repos = NULL, type="source", configure.args = "--with-gdal-config=/Library/Frameworks/GDAL.framework/Versions/1.10/unix/bin/gdal-config --with-proj-include=/Library/Frameworks/PROJ.framework/unix/include --with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib")
18/1.618
189+114
library(lubridate)
library(magrittr)
seasons <- data.frame(#
	   SE = as.POSIXct(c("2009-3-20", "2010-3-20", "2011-3-20", "2012-3-20", #
            "2013-3-20", "2014-3-20"), format="%Y-%m-%d"),#
	   SS = as.POSIXct(c("2009-6-21", "2010-6-21", "2011-6-21", "2012-6-20",#
            "2013-6-20", "2014-6-20"), format="%Y-%m-%d"),#
	   FE = as.POSIXct(c("2009-9-22", "2010-9-23", "2011-9-23", "2012-9-22",#
            "2013-9-22", "2014-9-22"), format="%Y-%m-%d"),#
	   WS = as.POSIXct(c("2009-12-21", "2010-12-21", "2011-12-22", "2012-12-21", #
            "2013-12-21", "2014-12-21"), format="%Y-%m-%d")#
    )#
#
    assignSeason <- function(dat, SeasonStarts=seasons) {#
	    dat %<>% mutate(#
		    Season = lapply(Date,#
				function(x) {#
					findInterval(#
						x, #
						SeasonStarts[which(year(x)==year(SeasonStarts$WS)), ]#
					)#
				}#
			) %>% unlist	#
		)#
	    dat[which(dat$Season==0 | dat$Season==4), ]$Season 	<- "Winter"#
	    dat[which(dat$Season==1), ]$Season 					<- "Spring"#
	    dat[which(dat$Season==2), ]$Season 					<- "Summer"#
	    dat[which(dat$Season==3), ]$Season 					<- "Fall"#
	    return(dat)#
    }
dat = data.frame(#
	    Date = as.POSIXct(strptime(as.Date("2011-12-01", format = "%Y-%m-%d") + #
            (0:10)*30, format="%Y-%m-%d" ))#
    )#
    dat %>% assignSeason
library(dplyr)
dat = data.frame(#
	    Date = as.POSIXct(strptime(as.Date("2011-12-01", format = "%Y-%m-%d") + #
            (0:10)*30, format="%Y-%m-%d" ))#
    )#
    dat %>% assignSeason
library(devtoolks)
library(devtools)
?install_github
devtools::install_github("ksauby/ACSampling", auth_token="2ab30a602e52fae481f4249cc25e892c0a9ccfc7", subdir="/code/Restricted_ACS_Simulations/ACSampling", repos=NULL)
devtools::install_github("ksauby/ACSampling", auth_token="2794c3f10db92f525181a0b1f6c19064fe3a2ef3", subdir="/code/Restricted_ACS_Simulations/ACSampling", repos=NULL)
devtools::install("~/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
devtools::install(pkg="~/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
devtools::install(pkg="Users/KSauby/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
devtools::install(pkg="~/Users/KSauby/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
devtools::install(pkg="/Users/KSauby/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
devtools::install_local(path="/Users/KSauby/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
library(devtools)
devtools::install_local(path="/Users/KSauby/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
devtools::install(pkg="/Users/KSauby/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
install.packages("~/Documents/Projects/ACSampling/code/Restricted_ACS_Simulations/ACSampling_0.0.0.9000.tar.gz")
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
??grid.newpage
??
pushViewport
??grid.layout
?viewport
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
?as.DAte
?as.Date
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
ggbiplot2 <- function (#
	pcobj, #
	choices = 1:2, #
	scale = 1, #
	pc.biplot = TRUE, #
    obs.scale = 1 - scale, #
	var.scale = scale, #
	groups = NULL, #
    ellipse = FALSE, #
	ellipse.prob = 0.68, #
	labels = NULL, #
	labels.size = 3, #
    alpha = 1, #
	var.axes = TRUE, #
	circle = FALSE, #
	circle.prob = 0.69, #
    varname.size = 3, #
	varname.adjust = 1.5, #
	varname.abbrev = FALSE, #
	color = muted("red"), # <- add new arguments to the function#
	linetype = "solid",#
	alpha_arrow = 1,#
	unit.circle.color=muted("white"),#
	varname.color = "darkred",#
	point.size=1,#
	line.size=line.size,#
	scale_shape_manual = scale_shape_manual,#
	#scale_colour_manual = scale_colour_manual,#
	scale_linetype_manual = scale_linetype_manual,#
	axis.text.size = 15,#
	axis.title.size = 20,#
	xlim = xlim,#
	ylim = ylim,#
	border.size=2,#
	point.color="black",#
	pct_x_buffer=0.5,#
	pct_y_buffer=0.5#
) #
{#
    stopifnot(length(choices) == 2)#
    if (inherits(pcobj, "prcomp")) {#
        nobs.factor <- sqrt(nrow(pcobj$x) - 1)#
        d <- pcobj$sdev#
        u <- sweep(pcobj$x, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- pcobj$rotation#
    }#
    else if (inherits(pcobj, "princomp")) {#
        nobs.factor <- sqrt(pcobj$n.obs)#
        d <- pcobj$sdev#
        u <- sweep(pcobj$scores, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- pcobj$loadings#
    }#
    else if (inherits(pcobj, "PCA")) {#
        nobs.factor <- sqrt(nrow(pcobj$call$X))#
        d <- unlist(sqrt(pcobj$eig)[1])#
        u <- sweep(pcobj$ind$coord, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- sweep(pcobj$var$coord, 2, sqrt(pcobj$eig[1:ncol(pcobj$var$coord), #
            1]), FUN = "/")#
    }#
    else if (inherits(pcobj, "lda")) {#
        nobs.factor <- sqrt(pcobj$N)#
        d <- pcobj$svd#
        u <- predict(pcobj)$x/nobs.factor#
        v <- pcobj$scaling#
        d.total <- sum(d^2)#
    }#
    else {#
        stop("Expected a object of class prcomp, princomp, PCA, or lda")#
    }#
    choices <- pmin(choices, ncol(u))#
    df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, #
        FUN = "*"))#
    v <- sweep(v, 2, d^var.scale, FUN = "*")#
    df.v <- as.data.frame(v[, choices])#
    names(df.u) <- c("xvar", "yvar")#
    names(df.v) <- names(df.u)#
    if (pc.biplot) {#
        df.u <- df.u * nobs.factor#
    }#
    r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)#
    v.scale <- rowSums(v^2)#
    df.v <- r * df.v/sqrt(max(v.scale))#
    if (obs.scale == 0) {#
        u.axis.labs <- paste("standardized PC", choices, sep = "")#
    }#
    else {#
        u.axis.labs <- paste("PC", choices, sep = "")#
    }#
    u.axis.labs <- paste(#
		u.axis.labs, #
		"(",#
		sprintf(#
			"explained var.=%0.0f%%, ", #
			100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)#
		),#
		"EV=", #
		round(pcobj$sdev[choices]^2, 1),#
		")",#
		sep=""#
	)#
    if (!is.null(labels)) {#
        df.u$labels <- labels#
    }#
    if (!is.null(groups)) {#
        df.u$groups <- groups#
    }#
    if (varname.abbrev) {#
        df.v$varname <- abbreviate(rownames(v))#
    }#
    else {#
        df.v$varname <- rownames(v)#
    }#
    df.v$angle <- with(df.v, (180/pi) * atan(yvar/xvar))#
    df.v$hjust <- with(df.v, (1 - varname.adjust * sign(xvar))/2)#
    g <- ggplot(data = df.u, aes(x = xvar, y = yvar)) + xlab(u.axis.labs[1]) + #
        ylab(u.axis.labs[2]) + coord_equal()#
    if (!is.null(df.u$labels)) {#
        if (!is.null(df.u$groups)) {#
            g <- g + geom_text(aes(label = labels, color = groups), #
                size = labels.size)#
        }#
        else {#
            g <- g + geom_text(#
						aes(label = labels), #
						size = labels.size#
			)#
        }#
    }#
    else {#
        if (!is.null(df.u$groups)) {#
            g <- g + geom_point(#
						aes(shape=groups), #
						alpha = alpha,#
						size=point.size,#
						color=point.color#
			)#
        }#
        else {#
            g <- g + geom_point(alpha = alpha)#
        }#
    }#
    if (!is.null(df.u$groups) && ellipse) {#
        theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))#
        circle <- cbind(cos(theta), sin(theta))#
        ell <- ddply(df.u, "groups", function(x) {#
            if (nrow(x) <= 2) {#
                return(NULL)#
            }#
            sigma <- var(cbind(x$xvar, x$yvar))#
            mu <- c(mean(x$xvar), mean(x$yvar))#
            ed <- sqrt(qchisq(ellipse.prob, df = 2))#
            data.frame(sweep(circle %*% chol(sigma) * ed, 2, #
                mu, FUN = "+"), groups = x$groups[1])#
        })#
        names(ell)[1:2] <- c("xvar", "yvar")#
        g <- g + geom_path(#
					data = ell, #
					aes(color = groups, group = groups, linetype=groups), size=line.size#
		)#
    }#
    if (var.axes) {#
        if (circle) {#
            theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, #
                length = 50))#
            circle <- data.frame(xvar = r * cos(theta), yvar = r * #
                sin(theta))#
            g <- g + geom_path(data = circle, color = unit.circle.color, #
                size = 1/2, alpha = 1/3)#
        }#
		g <- g + geom_segment(#
					data = df.v, #
					aes(x = 0, y = 0, xend = xvar, yend = yvar), #
					arrow = arrow(length = unit(1/2, "picas")), #
					color = color, #
					linetype = linetype, #
					alpha = alpha_arrow#
		)#
        g <- g + geom_text(#
					data = df.v, #
					aes(label = varname, x = xvar, y = yvar, angle = angle, hjust = hjust),#
					color=varname.color, #
					size = varname.size#,#
					#fontface = "bold"#
		)#
    }#
	# PC percent variation explained#
    u.axis.labs <- paste(sprintf("%0.0f%%", #
        100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))#
	u.axis.labs.tot <- paste(#
		sprintf("%0.0f%%", #
			round(#
				100 * pcobj$sdev[choices[1]]^2/sum(pcobj$sdev^2) + #
				100 * pcobj$sdev[choices[2]]^2/sum(pcobj$sdev^2), 0#
			)#
		)#
	)#
	u.axis.labs <- paste(#
		"PC Var.: ", #
		round(100 * pcobj$sdev[choices[1]]^2/sum(pcobj$sdev^2),0), #
		"+", #
		round(100 * pcobj$sdev[choices[2]]^2/sum(pcobj$sdev^2),0), #
		"=", #
		u.axis.labs.tot, sep="")#
	# eigenvectors#
	eigenvectors <- paste(#
		"EV: ", #
		round(pcobj$sdev[1]^2, 1), #
		", ", #
		round(pcobj$sdev[2]^2, 1), #
		sep=""#
	)#
#
	g <- g + theme(legend.direction = 'horizontal', legend.position = 'top') + #
		theme_bw() +#
		  theme(#
			axis.line = element_line(colour = "black"),#
		    panel.grid.major = element_blank(),#
		    panel.grid.minor = element_blank(),#
	        panel.border = element_rect(colour = "black", fill=NA, size=border.size),#
		    panel.background = element_blank(),#
			axis.text.x = element_text(size=axis.text.size),#
			axis.text.y = element_text(size=axis.text.size)#
		) +#
		scale_shape_manual(values=c(scale_shape_manual)) +#
		#scale_colour_manual(values = scale_colour_manual) +#
		scale_linetype_manual(values = scale_linetype_manual) +#
		theme(legend.position="none") +#
		theme(axis.title.y = element_text(size = axis.title.size)) +#
		theme(axis.title.x = element_text(size = axis.title.size)) +#
		xlim(xlim) +#
		ylim(ylim) +#
		annotate("text", #
		x = 0.1,#
			#x = xlim[2]-pct_x_buffer, #
			y = ylim[1]+pct_y_buffer, #
			label = u.axis.labs,#
			size=7) +#
		annotate("text", #
			x = 0.1, #
			y = ylim[1]+pct_y_buffer+0.75, #
			label = eigenvectors,#
			size=7) # + # PC1#
		#annotate("text", #
		#	x = xlim[1]+pct_x_buffer, #
	#		y = ylim[2]-pct_y_buffer, #
	#		label = u.axis.labs[2]) # PC2#
    return(g)#
}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
ggbiplot2 <- function (#
	pcobj, #
	choices = 1:2, #
	scale = 1, #
	pc.biplot = TRUE, #
    obs.scale = 1 - scale, #
	var.scale = scale, #
	groups = NULL, #
    ellipse = FALSE, #
	ellipse.prob = 0.68, #
	labels = NULL, #
	labels.size = 3, #
    alpha = 1, #
	var.axes = TRUE, #
	circle = FALSE, #
	circle.prob = 0.69, #
    varname.size = 3, #
	varname.adjust = 1.5, #
	varname.abbrev = FALSE, #
	color = muted("red"), # <- add new arguments to the function#
	linetype = "solid",#
	alpha_arrow = 1,#
	unit.circle.color=muted("white"),#
	varname.color = "darkred",#
	point.size=1,#
	line.size=line.size,#
	scale_shape_manual = scale_shape_manual,#
	#scale_colour_manual = scale_colour_manual,#
	scale_linetype_manual = scale_linetype_manual,#
	axis.text.size = 15,#
	axis.title.size = 20,#
	xlim = xlim,#
	ylim = ylim,#
	border.size=2,#
	point.color="black",#
	pct_x_buffer=0.5,#
	pct_y_buffer=0.5#
) #
{#
    stopifnot(length(choices) == 2)#
    if (inherits(pcobj, "prcomp")) {#
        nobs.factor <- sqrt(nrow(pcobj$x) - 1)#
        d <- pcobj$sdev#
        u <- sweep(pcobj$x, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- pcobj$rotation#
    }#
    else if (inherits(pcobj, "princomp")) {#
        nobs.factor <- sqrt(pcobj$n.obs)#
        d <- pcobj$sdev#
        u <- sweep(pcobj$scores, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- pcobj$loadings#
    }#
    else if (inherits(pcobj, "PCA")) {#
        nobs.factor <- sqrt(nrow(pcobj$call$X))#
        d <- unlist(sqrt(pcobj$eig)[1])#
        u <- sweep(pcobj$ind$coord, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- sweep(pcobj$var$coord, 2, sqrt(pcobj$eig[1:ncol(pcobj$var$coord), #
            1]), FUN = "/")#
    }#
    else if (inherits(pcobj, "lda")) {#
        nobs.factor <- sqrt(pcobj$N)#
        d <- pcobj$svd#
        u <- predict(pcobj)$x/nobs.factor#
        v <- pcobj$scaling#
        d.total <- sum(d^2)#
    }#
    else {#
        stop("Expected a object of class prcomp, princomp, PCA, or lda")#
    }#
    choices <- pmin(choices, ncol(u))#
    df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, #
        FUN = "*"))#
    v <- sweep(v, 2, d^var.scale, FUN = "*")#
    df.v <- as.data.frame(v[, choices])#
    names(df.u) <- c("xvar", "yvar")#
    names(df.v) <- names(df.u)#
    if (pc.biplot) {#
        df.u <- df.u * nobs.factor#
    }#
    r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)#
    v.scale <- rowSums(v^2)#
    df.v <- r * df.v/sqrt(max(v.scale))#
    if (obs.scale == 0) {#
        u.axis.labs <- paste("standardized PC", choices, sep = "")#
    }#
    else {#
        u.axis.labs <- paste("PC", choices, sep = "")#
    }#
    u.axis.labs <- paste(#
		u.axis.labs, #
		"(",#
		sprintf(#
			"explained var.=%0.0f%%, ", #
			100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)#
		),#
		"EV=", #
		round(pcobj$sdev[choices]^2, 1),#
		")",#
		sep=""#
	)#
    if (!is.null(labels)) {#
        df.u$labels <- labels#
    }#
    if (!is.null(groups)) {#
        df.u$groups <- groups#
    }#
    if (varname.abbrev) {#
        df.v$varname <- abbreviate(rownames(v))#
    }#
    else {#
        df.v$varname <- rownames(v)#
    }#
    df.v$angle <- with(df.v, (180/pi) * atan(yvar/xvar))#
    df.v$hjust <- with(df.v, (1 - varname.adjust * sign(xvar))/2)#
    g <- ggplot(data = df.u, aes(x = xvar, y = yvar)) + xlab(u.axis.labs[1]) + #
        ylab(u.axis.labs[2]) + coord_equal()#
    if (!is.null(df.u$labels)) {#
        if (!is.null(df.u$groups)) {#
            g <- g + geom_text(aes(label = labels, color = groups), #
                size = labels.size)#
        }#
        else {#
            g <- g + geom_text(#
						aes(label = labels), #
						size = labels.size#
			)#
        }#
    }#
    else {#
        if (!is.null(df.u$groups)) {#
            g <- g + geom_point(#
						aes(shape=groups), #
						alpha = alpha,#
						size=point.size,#
						color=point.color#
			)#
        }#
        else {#
            g <- g + geom_point(alpha = alpha)#
        }#
    }#
    if (!is.null(df.u$groups) && ellipse) {#
        theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))#
        circle <- cbind(cos(theta), sin(theta))#
        ell <- ddply(df.u, "groups", function(x) {#
            if (nrow(x) <= 2) {#
                return(NULL)#
            }#
            sigma <- var(cbind(x$xvar, x$yvar))#
            mu <- c(mean(x$xvar), mean(x$yvar))#
            ed <- sqrt(qchisq(ellipse.prob, df = 2))#
            data.frame(sweep(circle %*% chol(sigma) * ed, 2, #
                mu, FUN = "+"), groups = x$groups[1])#
        })#
        names(ell)[1:2] <- c("xvar", "yvar")#
        g <- g + geom_path(#
					data = ell, #
					aes(color = groups, group = groups, linetype=groups), size=line.size#
		)#
    }#
    if (var.axes) {#
        if (circle) {#
            theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, #
                length = 50))#
            circle <- data.frame(xvar = r * cos(theta), yvar = r * #
                sin(theta))#
            g <- g + geom_path(data = circle, color = unit.circle.color, #
                size = 1/2, alpha = 1/3)#
        }#
		g <- g + geom_segment(#
					data = df.v, #
					aes(x = 0, y = 0, xend = xvar, yend = yvar), #
					arrow = arrow(length = unit(1/2, "picas")), #
					color = color, #
					linetype = linetype, #
					alpha = alpha_arrow#
		)#
        g <- g + geom_text(#
					data = df.v, #
					aes(label = varname, x = xvar, y = yvar, angle = angle, hjust = hjust),#
					color=varname.color, #
					size = varname.size#,#
					#fontface = "bold"#
		)#
    }#
	# PC percent variation explained#
    u.axis.labs <- paste(sprintf("%0.0f%%", #
        100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))#
	u.axis.labs.tot <- paste(#
		sprintf("%0.0f%%", #
			round(#
				100 * pcobj$sdev[choices[1]]^2/sum(pcobj$sdev^2) + #
				100 * pcobj$sdev[choices[2]]^2/sum(pcobj$sdev^2), 0#
			)#
		)#
	)#
	u.axis.labs <- paste(#
		"PC Var.: ", #
		round(100 * pcobj$sdev[choices[1]]^2/sum(pcobj$sdev^2),0), #
		"+", #
		round(100 * pcobj$sdev[choices[2]]^2/sum(pcobj$sdev^2),0), #
		"=", #
		u.axis.labs.tot, sep="")#
	# eigenvectors#
	eigenvectors <- paste(#
		"EV: ", #
		round(pcobj$sdev[1]^2, 1), #
		", ", #
		round(pcobj$sdev[2]^2, 1), #
		sep=""#
	g <- g + theme(legend.direction = 'horizontal', legend.position = 'top') + #
		theme_bw() +#
		  theme(#
			axis.line = element_line(colour = "black"),#
		    panel.grid.major = element_blank(),#
		    panel.grid.minor = element_blank(),#
	        panel.border = element_rect(colour = "black", fill=NA, size=border.size),#
		    panel.background = element_blank(),#
			axis.text.x = element_text(size=axis.text.size),#
			axis.text.y = element_text(size=axis.text.size)#
		) +#
		scale_shape_manual(values=c(scale_shape_manual)) +#
		#scale_colour_manual(values = scale_colour_manual) +#
		scale_linetype_manual(values = scale_linetype_manual) +#
		theme(legend.position="none") +#
		theme(axis.title.y = element_text(size = axis.title.size)) +#
		theme(axis.title.x = element_text(size = axis.title.size)) +#
		xlim(xlim) +#
		ylim(ylim) +#
		annotate("text", #
		x = 0.1,#
			#x = xlim[2]-pct_x_buffer, #
			y = ylim[1]+pct_y_buffer, #
			label = u.axis.labs,#
			size=7) +#
		annotate("text", #
			x = 0.1, #
			y = ylim[1]+pct_y_buffer+0.75, #
			label = eigenvectors,#
			size=7) # + # PC1#
		#annotate("text", #
		#	x = xlim[1]+pct_x_buffer, #
	#		y = ylim[2]-pct_y_buffer, #
	#		label = u.axis.labs[2]) # PC2#
    return(g)#
}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
ggbiplot2 <- function (#
	pcobj, #
	choices = 1:2, #
	scale = 1, #
	pc.biplot = TRUE, #
    obs.scale = 1 - scale, #
	var.scale = scale, #
	groups = NULL, #
    ellipse = FALSE, #
	ellipse.prob = 0.68, #
	labels = NULL, #
	labels.size = 3, #
    alpha = 1, #
	var.axes = TRUE, #
	circle = FALSE, #
	circle.prob = 0.69, #
    varname.size = 3, #
	varname.adjust = 1.5, #
	varname.abbrev = FALSE, #
	color = muted("red"), # <- add new arguments to the function#
	linetype = "solid",#
	alpha_arrow = 1,#
	unit.circle.color=muted("white"),#
	varname.color = "darkred",#
	point.size=1,#
	line.size=line.size,#
	scale_shape_manual = scale_shape_manual,#
	#scale_colour_manual = scale_colour_manual,#
	scale_linetype_manual = scale_linetype_manual,#
	axis.text.size = 15,#
	axis.title.size = 20,#
	xlim = xlim,#
	ylim = ylim,#
	border.size=2,#
	point.color="black",#
	pct_x_buffer=0.5,#
	pct_y_buffer=0.5#
) #
{#
    stopifnot(length(choices) == 2)#
    if (inherits(pcobj, "prcomp")) {#
        nobs.factor <- sqrt(nrow(pcobj$x) - 1)#
        d <- pcobj$sdev#
        u <- sweep(pcobj$x, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- pcobj$rotation#
    }#
    else if (inherits(pcobj, "princomp")) {#
        nobs.factor <- sqrt(pcobj$n.obs)#
        d <- pcobj$sdev#
        u <- sweep(pcobj$scores, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- pcobj$loadings#
    }#
    else if (inherits(pcobj, "PCA")) {#
        nobs.factor <- sqrt(nrow(pcobj$call$X))#
        d <- unlist(sqrt(pcobj$eig)[1])#
        u <- sweep(pcobj$ind$coord, 2, 1/(d * nobs.factor), FUN = "*")#
        v <- sweep(pcobj$var$coord, 2, sqrt(pcobj$eig[1:ncol(pcobj$var$coord), #
            1]), FUN = "/")#
    }#
    else if (inherits(pcobj, "lda")) {#
        nobs.factor <- sqrt(pcobj$N)#
        d <- pcobj$svd#
        u <- predict(pcobj)$x/nobs.factor#
        v <- pcobj$scaling#
        d.total <- sum(d^2)#
    }#
    else {#
        stop("Expected a object of class prcomp, princomp, PCA, or lda")#
    }#
    choices <- pmin(choices, ncol(u))#
    df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, #
        FUN = "*"))#
    v <- sweep(v, 2, d^var.scale, FUN = "*")#
    df.v <- as.data.frame(v[, choices])#
    names(df.u) <- c("xvar", "yvar")#
    names(df.v) <- names(df.u)#
    if (pc.biplot) {#
        df.u <- df.u * nobs.factor#
    }#
    r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)#
    v.scale <- rowSums(v^2)#
    df.v <- r * df.v/sqrt(max(v.scale))#
    if (obs.scale == 0) {#
        u.axis.labs <- paste("standardized PC", choices, sep = "")#
    }#
    else {#
        u.axis.labs <- paste("PC", choices, sep = "")#
    }#
    u.axis.labs <- paste(#
		u.axis.labs, #
		"(",#
		sprintf(#
			"explained var.=%0.0f%%, ", #
			100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)#
		),#
		"EV=", #
		round(pcobj$sdev[choices]^2, 1),#
		")",#
		sep=""#
	)#
    if (!is.null(labels)) {#
        df.u$labels <- labels#
    }#
    if (!is.null(groups)) {#
        df.u$groups <- groups#
    }#
    if (varname.abbrev) {#
        df.v$varname <- abbreviate(rownames(v))#
    }#
    else {#
        df.v$varname <- rownames(v)#
    }#
    df.v$angle <- with(df.v, (180/pi) * atan(yvar/xvar))#
    df.v$hjust <- with(df.v, (1 - varname.adjust * sign(xvar))/2)#
    g <- ggplot(data = df.u, aes(x = xvar, y = yvar)) + xlab(u.axis.labs[1]) + #
        ylab(u.axis.labs[2]) + coord_equal()#
    if (!is.null(df.u$labels)) {#
        if (!is.null(df.u$groups)) {#
            g <- g + geom_text(aes(label = labels, color = groups), #
                size = labels.size)#
        }#
        else {#
            g <- g + geom_text(#
						aes(label = labels), #
						size = labels.size#
			)#
        }#
    }#
    else {#
        if (!is.null(df.u$groups)) {#
            g <- g + geom_point(#
						aes(shape=groups), #
						alpha = alpha,#
						size=point.size,#
						color=point.color#
			)#
        }#
        else {#
            g <- g + geom_point(alpha = alpha)#
        }#
    }#
    if (!is.null(df.u$groups) && ellipse) {#
        theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))#
        circle <- cbind(cos(theta), sin(theta))#
        ell <- ddply(df.u, "groups", function(x) {#
            if (nrow(x) <= 2) {#
                return(NULL)#
            }#
            sigma <- var(cbind(x$xvar, x$yvar))#
            mu <- c(mean(x$xvar), mean(x$yvar))#
            ed <- sqrt(qchisq(ellipse.prob, df = 2))#
            data.frame(sweep(circle %*% chol(sigma) * ed, 2, #
                mu, FUN = "+"), groups = x$groups[1])#
        })#
        names(ell)[1:2] <- c("xvar", "yvar")#
        g <- g + geom_path(#
					data = ell, #
					aes(color = groups, group = groups, linetype=groups), size=line.size#
		)#
    }#
    if (var.axes) {#
        if (circle) {#
            theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, #
                length = 50))#
            circle <- data.frame(xvar = r * cos(theta), yvar = r * #
                sin(theta))#
            g <- g + geom_path(data = circle, color = unit.circle.color, #
                size = 1/2, alpha = 1/3)#
        }#
		g <- g + geom_segment(#
					data = df.v, #
					aes(x = 0, y = 0, xend = xvar, yend = yvar), #
					arrow = arrow(length = unit(1/2, "picas")), #
					color = color, #
					linetype = linetype, #
					alpha = alpha_arrow#
		)#
        g <- g + geom_text(#
					data = df.v, #
					aes(label = varname, x = xvar, y = yvar, angle = angle, hjust = hjust),#
					color=varname.color, #
					size = varname.size#,#
					#fontface = "bold"#
		)#
    }#
	# PC percent variation explained#
    u.axis.labs <- paste(sprintf("%0.0f%%", #
        100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))#
	u.axis.labs.tot <- paste(#
		sprintf("%0.0f%%", #
			round(#
				100 * pcobj$sdev[choices[1]]^2/sum(pcobj$sdev^2) + #
				100 * pcobj$sdev[choices[2]]^2/sum(pcobj$sdev^2), 0#
			)#
		)#
	)#
	u.axis.labs <- paste(#
		"PC Var.: ", #
		round(100 * pcobj$sdev[choices[1]]^2/sum(pcobj$sdev^2),0), #
		"+", #
		round(100 * pcobj$sdev[choices[2]]^2/sum(pcobj$sdev^2),0), #
		"=", #
		u.axis.labs.tot, sep="")#
	# eigenvectors#
	eigenvectors <- paste(#
		"EV: ", #
		round(pcobj$sdev[1]^2, 1), #
		", ", #
		round(pcobj$sdev[2]^2, 1), #
		sep=""#
	)#
#
	g <- g + theme(legend.direction = 'horizontal', legend.position = 'top') + #
		theme_bw() +#
		  theme(#
			axis.line = element_line(colour = "black"),#
		    panel.grid.major = element_blank(),#
		    panel.grid.minor = element_blank(),#
	        panel.border = element_rect(colour = "black", fill=NA, size=border.size),#
		    panel.background = element_blank(),#
			axis.text.x = element_text(size=axis.text.size),#
			axis.text.y = element_text(size=axis.text.size)#
		) +#
		scale_shape_manual(values=c(scale_shape_manual)) +#
		#scale_colour_manual(values = scale_colour_manual) +#
		scale_linetype_manual(values = scale_linetype_manual) +#
		theme(legend.position="none") +#
		theme(axis.title.y = element_text(size = axis.title.size)) +#
		theme(axis.title.x = element_text(size = axis.title.size)) +#
		xlim(xlim) +#
		ylim(ylim) +#
		annotate("text", #
		x = 0.1,#
			#x = xlim[2]-pct_x_buffer, #
			y = ylim[1]+pct_y_buffer, #
			label = u.axis.labs,#
			size=7) +#
		annotate("text", #
			x = 0.1, #
			y = ylim[1]+pct_y_buffer+0.75, #
			label = eigenvectors,#
			size=7) # + # PC1#
		#annotate("text", #
		#	x = xlim[1]+pct_x_buffer, #
	#		y = ylim[2]-pct_y_buffer, #
	#		label = u.axis.labs[2]) # PC2#
    return(g)#
}
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
