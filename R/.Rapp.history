21.4*.813
21.4 -21.4*.813
library(lubridaste)
library(lubrida=te)
library(lubridate)
-v
install.packages("rgeos", repos="http://R-Forge.R-project.org")#
require(rgeos)
library(rgeos)
require(rgeos)
library(rgeos)
install.packages("rgdal", repos="http://R-Forge.R-project.org")#
require(rgdal)
R CMD INSTALL ~/Downloads/rgdal_0.9-1.tar.gz --configure-args='--with-gdal-config=/Library/Frameworks/GDAL.framework/Programs/gdal-config#
 --with-proj-include=/Library/Frameworks/PROJ.framework/Headers#
 --with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib'
R CMD INSTALL ~/Downloads/rgdal_0.9-1.tar.gz --configure-args='--with-gdal-config=/Library/Frameworks/GDAL.framework/Programs/gdal-config--with-proj-include=/Library/Frameworks/PROJ.framework/Headers--with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib'
library(lme3)
library(lme4)
300/241
.244*30
1.25*300
1.25*240
7*12
7849-7527
322/1353
8028-7527
501/1353
8028-7957
1353-501
852/71
7956-7878
8176-8029
8176-8092
250*.75
250*.25
42*2 + 17*2
118/19
21/6.2
59.5*.75
59.5*.5 + 59.5
71/12
597/80
597/8
432/8
15*8 + 9*3
?seq_len
7.25/3
7.25/4
for(i in 0:9){x=cos(2*pi/10*i);y=x+1;z=(y-2)*22;pie(c(y,8-y),col=c(0,7),init.angl=135-z,bo=F,la=NA)}
install.packages("ProjectTemplate")
install.packages("dplyr")
install.packages("ggplot2")
install.packages("data.table")
install.packages("corrgram")
install.packages("survival")
install.packages("shapefiles")
install.packages("rgdal")
install.packages("PBSmapping")
install.packages("sp")
install.packages("gdistance")
install.packages("chron")
install.packages("unmarked")
install.packages("lme4")
install.packages("rgeos", repos="http://R-Forge.R-project.org", type="source")#
require(rgeos)
install.packages('rgdal',repos="http://www.stats.ox.ac.uk/pub/RWin")
library(rgdal)
install.packages("http://cran.r-project.org/src/contrib/rgdal_0.9-1.tar.gz", repos = NULL, type="source", configure.args = "--with-gdal-config=/Library/Frameworks/GDAL.framework/Versions/1.10/unix/bin/gdal-config --with-proj-include=/Library/Frameworks/PROJ.framework/unix/include --with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib")
18/1.618
189+114
library(lubridate)
library(magrittr)
seasons <- data.frame(#
	   SE = as.POSIXct(c("2009-3-20", "2010-3-20", "2011-3-20", "2012-3-20", #
            "2013-3-20", "2014-3-20"), format="%Y-%m-%d"),#
	   SS = as.POSIXct(c("2009-6-21", "2010-6-21", "2011-6-21", "2012-6-20",#
            "2013-6-20", "2014-6-20"), format="%Y-%m-%d"),#
	   FE = as.POSIXct(c("2009-9-22", "2010-9-23", "2011-9-23", "2012-9-22",#
            "2013-9-22", "2014-9-22"), format="%Y-%m-%d"),#
	   WS = as.POSIXct(c("2009-12-21", "2010-12-21", "2011-12-22", "2012-12-21", #
            "2013-12-21", "2014-12-21"), format="%Y-%m-%d")#
    )#
#
    assignSeason <- function(dat, SeasonStarts=seasons) {#
	    dat %<>% mutate(#
		    Season = lapply(Date,#
				function(x) {#
					findInterval(#
						x, #
						SeasonStarts[which(year(x)==year(SeasonStarts$WS)), ]#
					)#
				}#
			) %>% unlist	#
		)#
	    dat[which(dat$Season==0 | dat$Season==4), ]$Season 	<- "Winter"#
	    dat[which(dat$Season==1), ]$Season 					<- "Spring"#
	    dat[which(dat$Season==2), ]$Season 					<- "Summer"#
	    dat[which(dat$Season==3), ]$Season 					<- "Fall"#
	    return(dat)#
    }
dat = data.frame(#
	    Date = as.POSIXct(strptime(as.Date("2011-12-01", format = "%Y-%m-%d") + #
            (0:10)*30, format="%Y-%m-%d" ))#
    )#
    dat %>% assignSeason
library(dplyr)
dat = data.frame(#
	    Date = as.POSIXct(strptime(as.Date("2011-12-01", format = "%Y-%m-%d") + #
            (0:10)*30, format="%Y-%m-%d" ))#
    )#
    dat %>% assignSeason
library(magrittr)
library(lubridate)
library(dplyr)
seasons <- data.frame(#
	   SE = as.POSIXct(c("2009-3-20", "2010-3-20", "2011-3-20", "2012-3-20", #
            "2013-3-20", "2014-3-20"), format="%Y-%m-%d"),#
	   SS = as.POSIXct(c("2009-6-21", "2010-6-21", "2011-6-21", "2012-6-20",#
            "2013-6-21", "2014-6-21"), format="%Y-%m-%d"),#
	   FE = as.POSIXct(c("2009-9-22", "2010-9-23", "2011-9-23", "2012-9-22",#
            "2013-9-22", "2014-9-23"), format="%Y-%m-%d"),#
	   WS = as.POSIXct(c("2009-12-21", "2010-12-21", "2011-12-22", "2012-12-21", #
            "2013-12-21", "2014-12-21"), format="%Y-%m-%d")#
    )#
#
    assignSeason <- function(dat, SeasonStarts=seasons) {#
	    dat %<>% mutate(#
		    Season = lapply(Date,#
				function(x) {#
					findInterval(#
						x, #
						SeasonStarts[which(year(x)==year(SeasonStarts$WS)), ]#
					)#
				}#
			) %>% unlist	#
		)#
	    dat[which(dat$Season==0 | dat$Season==4), ]$Season 	 <- "Winter"#
	    dat[which(dat$Season==1), ]$Season 					<- "Spring"#
	    dat[which(dat$Season==2), ]$Season 					<- "Summer"#
	    dat[which(dat$Season==3), ]$Season 					<- "Fall"#
	    return(dat)#
    }
dat = data.frame(#
	    Date = as.POSIXct(strptime(as.Date("2011-12-01", format = "%Y-%m-%d") + #
            (0:10)*30, format="%Y-%m-%d"))#
    )#
    dat %>% assignSeason
dim(seasons)
dput(GrowingArealog90s[1:10,])#
structure(list(SampleDate = structure(c(6948, 6949, 6950, 7516, #
7517, 7782, 7783, 7784, 8092, 8106), class = "Date"), Flog90 =  c(1.51851393987789, #
1.48970743802793, 1.81243963000062, 0.273575501327576, 0.874218895695207, #
1.89762709129044, 1.44012088794774, 0.301029995663981, 1.23603370361931, #
0.301029995663981)), .Names = c("SampleDate", "Flog90"), class = c("tbl_df", #
"data.frame"), row.names = c(NA, -10L))
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
timeseries <- processData(timeseries.25Jan2015JK.mod)#
timeseries <- removeData(timeseries)#
#
# climate_data <- processWeather()#
#
################################################################################
# timeseries_survival#
################################################################################
timeseries_survival	 	<- createSurvivalDataset(timeseries)#
#
# rescale, drop levels, reorder#
timeseries_survival_stricta = timeseries_survival %>% #
	as.data.frame %>%#
	filter(Species=="Opuntia stricta") %>%#
	droplevels#
timeseries_survival_stricta$PlantID2 %<>% factor#
#
timeseries_survival_humifusa = timeseries_survival %>% #
	as.data.frame %>%#
	filter(Species=="Opuntia humifusa") %>%#
	droplevels#
timeseries_survival_humifusa$PlantID2 %<>% factor#
#
setwd('/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series')#
cache("timeseries_survival_stricta")#
cache("timeseries_survival_humifusa")#
#
setwd('/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/data')#
write.csv(timeseries_survival_stricta, "timeseries_survival_stricta.csv")#
write.csv(timeseries_survival_humifusa, "timeseries_survival_humifusa.csv")#
################################################################################
# timeseries_all_surveys#
################################################################################
timeseries_all_surveys <- createAllSurveysDataset(timeseries)#
#
setwd("/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/")#
cache("timeseries_all_surveys")#
write.csv(timeseries_all_surveys, "./data/timeseries_all_surveys.csv")#
#
################################################################################
# timeseries_winter#
################################################################################
timeseries_winter <- createFallWinterSurveysDataset(timeseries)#
#
setwd("/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/")#
cache("timeseries_winter")#
write.csv(timeseries_winter, "./data/timeseries_winter.csv")#
#
################################################################################
# timeseries_spring#
################################################################################
timeseries_spring <- createSpringSummerSurveysDataset(timeseries)#
#
setwd("/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/")#
cache("timeseries_spring")#
write.csv(timeseries_spring, "./data/timeseries_spring.csv")
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series')
library(ProjectTemplate)#
setwd("/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series")#
# load project#
load.project()
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
timeseries <- processData(timeseries.25Jan2015JK.mod)#
timeseries <- removeData(timeseries)#
#
# climate_data <- processWeather()#
#
################################################################################
# timeseries_survival#
################################################################################
timeseries_survival	 	<- createSurvivalDataset(timeseries)#
#
# rescale, drop levels, reorder#
timeseries_survival_stricta = timeseries_survival %>% #
	as.data.frame %>%#
	filter(Species=="Opuntia stricta") %>%#
	droplevels#
timeseries_survival_stricta$PlantID2 %<>% factor#
#
timeseries_survival_humifusa = timeseries_survival %>% #
	as.data.frame %>%#
	filter(Species=="Opuntia humifusa") %>%#
	droplevels#
timeseries_survival_humifusa$PlantID2 %<>% factor#
#
setwd('/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series')#
cache("timeseries_survival_stricta")#
cache("timeseries_survival_humifusa")#
#
setwd('/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/data')#
write.csv(timeseries_survival_stricta, "timeseries_survival_stricta.csv")#
write.csv(timeseries_survival_humifusa, "timeseries_survival_humifusa.csv")#
################################################################################
# timeseries_all_surveys#
################################################################################
timeseries_all_surveys <- createAllSurveysDataset(timeseries)#
#
setwd("/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/")#
cache("timeseries_all_surveys")#
write.csv(timeseries_all_surveys, "./data/timeseries_all_surveys.csv")#
#
################################################################################
# timeseries_winter#
################################################################################
timeseries_winter <- createFallWinterSurveysDataset(timeseries)#
#
setwd("/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/")#
cache("timeseries_winter")#
write.csv(timeseries_winter, "./data/timeseries_winter.csv")#
#
################################################################################
# timeseries_spring#
################################################################################
timeseries_spring <- createSpringSummerSurveysDataset(timeseries)#
#
setwd("/Users/KSauby/Documents/Dropbox/GradSchool/Research/Projects/marsico-time-series/")#
cache("timeseries_spring")#
write.csv(timeseries_spring, "./data/timeseries_spring.csv")
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
timeseries_all_surveys$Date %<>%#
		strptime("%Y-%m-%d") %>%#
		as.POSIXct(format="%Y-%m-%d")#
	timeseries_all_surveys %<>% as.data.frame %>% assignSeason
str(timeseries_all_surveys)
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
wstations <- ghcnd.stations.NW.FL.current#
Location_list <- c("BLSP", "HBSP", "MB", "N", "SASP", "TSP")
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
wstations$Start_Date <- sub(" .*", "", #
		wstations$Date_Range)#
	wstations$End_Date <- sub(".* ", "", #
		wstations$Date_Range)#
	# filter dates to study dates#
	wstations %<>%#
		filter(Start_Date <= "2014-01-17", End_Date >= "2008-01-20") %>%#
		# merge with list of weather stations for which start/end date is not known#
		rbind(filter(wstations, Start_Date == "", End_Date >= ""))
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality %>%#
		formatconvertClimateData#
	#---------------------------- Restrict start and end dates --------------- ##
	climate_data %<>% filter(Date <= "2014-01-17", Date >= "2008-01-20")#
	Datalist <- findClosestWeatherStations(sites, climate_data, Distance=85) #
	climate_data <- getClimateDataByLocationDate(Datalist)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
# list of climate files to fix#
climate_file_names <- c("NOAA.ApalachicolaAirport", "NOAA.ApalachicolaAirport1", "NOAA.Bloxham", "NOAA.Bristol2", "NOAA.Callaway03", "NOAA.Callaway06S", "NOAA.Chipley", "NOAA.Clarksville2N", "NOAA.CrestviewBobSikesAirport", "NOAA.DeFuniakSprings", "NOAA.Destin1", "NOAA.DestinFortWaltonBeach", "NOAA.Freeport34", "NOAA.Freeport40SSW", "NOAA.Freeport44", "NOAA.Hosford27", "NOAA.Marianna7NE", "NOAA.NavalLiveOaks", "NOAA.NWFLBeaches", "NOAA.PanamaCity", "NOAA.PanamaCityBayCoAirport", "NOAA.PanamaCityBeach03", "NOAA.PanamaCityBeach12ESE", "NOAA.PensacolaForest", "NOAA.PensacolaRegionalAirport", "NOAA.PortStJoe06", "NOAA.PortStJoe81", "NOAA.Quincy3SSW", "NOAA.Sumatra", "NOAA.Telogia", "NOAA.ValparaisoEglinAFB", "NOAA.Vernon106", "NOAA.WestPensacola109", "NOAA.Wewahitchka", "NOAA.Wewahitchka16", "NOAA.Wilma", "NOAA.WoodruffDam", "NOAA.Bellview17", "NOAA.Pensacola92", "NOAA.MiramarBeach95", "NOAA.InletBeach07", "NOAA.PanamaCityBeach59", "NOAA.Apalachicola08WNW", "NOAA.NewHope", "NOAA.Destin15")#
mergeClimateFiles <- function(climate_file_names) {#
	X <- list()#
	for (h in 1:length(climate_file_names)) {#
		# PRCP, TMIN, TMAX name vectors#
		TMIN_vector <- vector()#
		TMAX_vector <- vector()#
		PRCP_vector <- vector()#
		# pull climate file#
		Y <- eval(parse(text=climate_file_names[h]))#
		X[[h]] <- list()#
		# select weather station info to keep#
		X[[h]][[1]] <- Y %>% select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)#
		# counter for weather variable (have to count because not all files have all weather variables)#
		k=2 # start at 2 because weather station info goes in [[1]]#
		# fix PRCP flag column names#
		if ("PRCP" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="PRCP")) : #
				(which(colnames(Y)=="PRCP")+4)]#
			for (i in 1:4) {#
				PRCP_vector[i] <- paste(#
					"PRCP", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="PRCP") #
							+ i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- PRCP_vector#
			k <- k + 1#
		}#
		# fix TMIN flag column names#
		if ("TMIN" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMIN")) : #
				(which(colnames(Y)=="TMIN")+4)]#
			for (i in 1:4) {#
				TMIN_vector[i] <- paste(#
					"TMIN", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMIN") + i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- TMIN_vector#
			k <- k + 1#
		}#
		# fix TMAX flag column names#
		if ("TMAX" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMAX")) : #
				(which(colnames(Y)=="TMAX")+4)]#
			for (i in 1:4) {#
				TMAX_vector[i] <- paste(#
					"TMAX", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMAX") + i])#
					), #
					"Flag", #
					sep="."#
				)		#
			}#
			names(X[[h]][[k]])[2:5] <- TMAX_vector#
		}#
	}#
	# merge list of lists of lists#
	data.array2 <- list()#
	for (i in 1:length(unique(climate_file_names))) {#
		data.array2[[i]] = as.data.frame(#
			mapply(#
				cbind, #
				unlist(#
					X[[i]], #
					recursive=F#
				)#
			)#
		)#
	}	#
	do.call(rbind.fill, data.array2)#
}#
#'  \item Filter data by quality#
#' 		\itemize{#
#' 			\item replace data with NA if it is of questionable quality (see \code{Quality_Flag_Function} function for details)#
#' 			\item replace blank values (quality is okay) with "Okay"#
#' 			\item Replace -999 and blanks with NAs#
#' 		}#
#
#--------------------------------------------------------------------------##
# Filter data by quality#
#--------------------------------------------------------------------------##
# replace data with NA if it is of questionable quality#
filterClimateDataByQuality <- function(climate_data) {#
	climate_data$PRCP <- with(#
		climate_data, #
		Quality_Flag_Function(PRCP, PRCP.Quality.Flag)#
	)#
	climate_data$TMIN <- with(#
		climate_data, #
		Quality_Flag_Function(TMIN, TMIN.Quality.Flag)#
	)#
	climate_data$TMAX <- with(#
		climate_data, #
		Quality_Flag_Function(TMAX, TMAX.Quality.Flag)#
	)#
	# replace blank values (quality is okay) with "Okay"#
	climate_data[,c(#
		"PRCP.Quality.Flag", #
		"TMIN.Quality.Flag",#
		"TMAX.Quality.Flag"#
	)] %<>% apply(., 2, Replace_Blank_w_Okay_Function)#
	# Replace -999 and blanks with NAs#
	climate_data[,c(#
		"STATION", #
		"STATION_NAME",#
		"ELEVATION",#
		"LATITUDE",#
		"LONGITUDE",#
		"DATE",#
		"PRCP",#
		"PRCP.Measurement.Flag",#
		"PRCP.Quality.Flag",#
		"PRCP.Source.Flag",#
		"PRCP.Time.Flag",#
		"TMIN",#
		"TMIN.Measurement.Flag",#
		"TMIN.Quality.Flag",#
		"TMIN.Source.Flag",#
		"TMIN.Time.Flag",#
		"TMAX",#
		"TMAX.Measurement.Flag",#
		"TMAX.Quality.Flag",#
		"TMAX.Source.Flag",#
		"TMAX.Time.Flag"#
	)] %<>% apply(., 2, NA_Function)#
	return(climate_data)#
}#
#------------------------------------- Format/convert weather data -------##
#'  \item Format/convert weather data#
#' 		\itemize{#
#' 			\item convert tenths of Celcius to Celsius#
#' 			\item convert tenths of Celcius to Celsius#
#' 			\item convert PRCP (in tenths of mm) to cm#
#' 			\item replace NA for precip less than 0#
#' 		}#
formatconvertClimateData <- function(climate_data) {#
	climate_data[,c(#
		"PRCP",#
		"TMIN",#
		"TMAX"#
	)] %<>% apply(., 2, as.numeric)#
	climate_data %<>% mutate(#
			MinTemp = TMIN/10, # convert tenths of Celcius to Celsius#
			MaxTemp = TMAX/10, # convert tenths of Celcius to Celsius#
			Precip = PRCP/100, # convert PRCP (in tenths of mm) to cm#
			Date = as.Date(as.character(DATE), "%Y%m%d")#
		)#
	# replace NAs again just in case#
	climate_data[,c("MinTemp","MaxTemp","Precip")] %<>% apply(., 2, NA_Function)#
	# replace NA for precip#
	climate_data$Precip[which(climate_data$Precip < 0)] <- NA#
	return(climate_data)#
}#
	#-------------- Find closest weather stations to each sampling location -- ##
	sites <- Marsico.Florida.data.collection.site.location.summary#
	# distance - radius within which to look for nearby climate stations#
findClosestWeatherStations <- function(sites, climate_data, Distance=85) {#
	# merge sampling locations and weather station locations to calculate distance matrix (all pairwise distances among points)#
	A <- sites %>%#
		dplyr::select(Location.name, Latitude, Longitude) %>%#
		rbind.fill(dplyr::select(wstations, Name, Latitude, Longitude))#
	# first convert sampling locations and weather station coordinates to UTM#
	coordinates(A) <- c("Longitude", "Latitude")#
	proj4string(A) <- CRS("+proj=longlat +datum=WGS84")  ## for example#
	# then calculate dist matrix (which will now be in m)#
	A %<>% spTransform(CRS("+proj=utm +zone=16 ellps=WGS84"))#
	# convert coordinates back to numeric#
	A <- as.data.frame(cbind(A$Name, A@coords))#
	names(A) <- c("Name", "Easting", "Northing")#
	A[,c("Easting", "Northing")] %<>% apply(., 2, as.numeric)#
	# convert coordinate units to km#
	A[,c("Easting", "Northing")] %<>% apply(., 2, function(x) {x/1000})#
	# calculate distance matrix#
	distance_matrix <- as.data.frame(#
		as.matrix(#
			dist(#
				cbind(A$Easting, A$Northing), #
				method="euclidian"#
			)#
		)#
	)#
	# modify distance matrix#
	# 		keep columns 1:6 (correspond to the 6 sampling locations)#
	# 		keep rows 7:170 (correspond to the weather stations)#
	distance_matrix <- distance_matrix[7:134, 1:6]#
	names(distance_matrix) <- Location_list#
	# merge distance matrix with weather station info#
	B <- dplyr::select(#
		wstations, #
		Name, #
		Station.ID, #
		Latitude, #
		Longitude, #
		Precipitation, #
		Temperature, #
		Used_in_Analysis, #
		Sampling_Site, #
		Near_Sampling_Site, #
		Date_Range#
	)#
	distance_matrix %<>% cbind(B)#
	# change distance matrix columns to one column#
	weather_station_info <- reshape2::melt(#
		distance_matrix, #
		id.vars=c(#
			"Name", #
			"Station.ID", #
			"Latitude", #
			"Longitude", #
			"Precipitation", #
			"Temperature", #
			"Used_in_Analysis", #
			"Sampling_Site", #
			"Near_Sampling_Site", #
			"Date_Range"#
		)#
	)#
	names(weather_station_info)[(dim(weather_station_info)[2]-1) : #
		dim(weather_station_info)[2]] <- c("Sampling_Location", "Distance")#
	# standardize Station IDs - remove "GHCND:" if the the ID has it#
	weather_station_info$Station.ID <- gsub(#
		"^.*\\:", "", #
		weather_station_info$Station.ID#
	)#
	climate_data$STATION <- gsub("^.*\\:", "", climate_data$STATION)#
	# SELECT CLOSEST WEATHER STATIONS FOR EACH SAMPLING LOCATION#
	# merge distance data with climate_data#
	climate_data_temp <- weather_station_info %>% #
		dplyr::select(Station.ID, Sampling_Location, Distance) %>%#
		merge(climate_data, by.x="Station.ID", by.y="STATION")#
	BLSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="BLSP" & Distance <= Distance)#
	HBSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="HBSP" & Distance <= Distance) %>% #
		arrange(Date)#
	MB_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="MB" & Distance <= Distance)#
	N_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="N" & Distance <= Distance)#
	SASP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="SASP" & Distance <= Distance)#
	TSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="TSP" & Distance <= Distance)#
	# create list of climate stations per sampling location#
	Dat = list(#
		`climate_data`	= climate_data_temp,#
		`BLSP_stations` = BLSP_stations,#
		`HBSP_stations` = HBSP_stations,#
		`MB_stations` 	= MB_stations,#
		`N_stations` 	= N_stations,#
		`SASP_stations` = SASP_stations,#
		`TSP_stations` 	= TSP_stations#
	)#
	return(Dat)#
}#
getClimateDataByLocationDate <- function(Datalist) {#
	#Choose closest weather variable measurement for each Location/Date combo -##
	X <- list()#
	# for each LOCATION#
	for (i in 1:length(Location_list)) {#
		X[[i]] <- list()#
		# pull climate data for that location and merge with station data to get distance from station to sampling location#
		data = eval(parse(text=paste(#
			"Datalist$", #
			Location_list[i], #
			"_stations", #
			sep=""#
		)))#
		# PRECIPITATION#
		P 			<- data %>% filter(!is.na(Precip))#
		X[[i]][[1]] <- as.data.frame(matrix(NA, length(unique(P$Date)), 6))#
		names(X[[i]][[1]]) <- c(#
			"Precip_STATION_NAME", #
			"Precip_STATION", #
			"Precip_STATION_Distance", #
			"Date", #
			"Precip", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(P$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[1]][j, ] = P %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					Precip_STATION_NAME 	= STATION_NAME,#
					Precip_STATION 			= Station.ID,#
					Precip_STATION_Distance = Distance,#
					Date 					= Date[1],#
					Precip 					= Precip#
				)#
		}#
		# MIN TEMPERATURE#
		Min 		<- data %>% filter(!is.na(MinTemp))#
		X[[i]][[2]] <- as.data.frame(matrix(NA, length(unique(Min$Date)), 6))#
		names(X[[i]][[2]]) <- c(#
			"MinTemp_STATION_NAME", #
			"MinTemp_STATION", #
			"MinTemp_STATION_Distance", #
			"Date", #
			"MinTemp", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(Min$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[2]][j, ] = Min %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					MinTemp_STATION_NAME 		= STATION_NAME,#
					MinTemp_STATION 			= Station.ID,#
					MinTemp_STATION_Distance 	= Distance,#
					Date 						= Date,#
					MinTemp 					= MinTemp#
				)#
		}#
		# MAX TEMPERATURE#
		Max <- data %>% filter(!is.na(MaxTemp))#
		X[[i]][[3]] <- as.data.frame(matrix(NA, length(unique(Max$Date)), 6))#
		names(X[[i]][[3]]) <- c(#
			"MaxTemp_STATION_NAME", #
			"MaxTemp_STATION", #
			"MaxTemp_STATION_Distance", #
			"Date", #
			"MaxTemp", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(Max$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[3]][j, ] = Max %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					MaxTemp_STATION_NAME 		= STATION_NAME,#
					MaxTemp_STATION 			= Station.ID,#
					MaxTemp_STATION_Distance 	= Distance,#
					Date 						= Date,#
					MaxTemp 					= MaxTemp#
				)#
		}#
		X[[i]][[1]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[2]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[3]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[1]]$Location = Location_list[i]#
		X[[i]][[2]]$Location = Location_list[i]#
		X[[i]][[3]]$Location = Location_list[i]#
	}#
	# merge list of lists of lists#
	data.array2 <- list()#
	# for each density#
	for (i in 1:length(Location_list)) {#
	# for (i in 1:length(unique(patch_data$density))) {#
		# compress list of statistics to dataframe#
		data.array2[[i]] = join_all(X[[i]], by="Date", type="full")#
	}	#
	climate_data = do.call(rbind.fill, data.array2)#
}#
#############################################################################
# calculate growing degree days#
#############################################################################
# used this website to calculate growing degree days: http://www.ipm.ucdavis.edu/WEATHER/ddretrievetext.html#
# merge UCD IPM files into one#
DegreeDay_list <- c(#
	"UCD.IPM.BLSPDegree.days",#
	"UCD.IPM.HBSPDegree.days",#
	"UCD.IPM.MexicoBeachDegree.days",#
	"UCD.IPM.NokuseDegree.days",#
	"UCD.IPM.SASPDegree.days",#
	"UCD.IPM.SweetwaterDegree.days"#
)#
calculateDegreeDays <- function(DegreeDay_list, climate_data) {#
	X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)#
	DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)#
	names(DegreeDays.merged)[2:3] <- c("MinTemp", "MaxTemp")#
	return(DegreeDays.merged)#
}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality %>%#
		formatconvertClimateData#
	#---------------------------- Restrict start and end dates --------------- ##
	climate_data %<>% filter(Date <= "2014-01-17", Date >= "2008-01-20")#
	Datalist <- findClosestWeatherStations(sites, climate_data, Distance=85) #
	climate_data <- getClimateDataByLocationDate(Datalist)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
wstations <- ghcnd.stations.NW.FL.current#
Location_list <- c("BLSP", "HBSP", "MB", "N", "SASP", "TSP")
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
wstations$Start_Date <- sub(" .*", "", #
		wstations$Date_Range)#
	wstations$End_Date <- sub(".* ", "", #
		wstations$Date_Range)#
	# filter dates to study dates#
	wstations %<>%#
		filter(Start_Date <= "2014-01-17", End_Date >= "2008-01-20") %>%#
		# merge with list of weather stations for which start/end date is not known#
		rbind(filter(wstations, Start_Date == "", End_Date >= ""))#
	#############################################################################
	# MODIFY INDIVIDUAL WEATHER STATION FILES#
	#############################################################################
	climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality %>%#
		formatconvertClimateData#
	#---------------------------- Restrict start and end dates --------------- ##
	climate_data %<>% filter(Date <= "2014-01-17", Date >= "2008-01-20")#
	Datalist <- findClosestWeatherStations(sites, climate_data, Distance=85) #
	climate_data <- getClimateDataByLocationDate(Datalist)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
formatconvertClimateData <- function(climate_data) {#
	climate_data[,c(#
		"PRCP",#
		"TMIN",#
		"TMAX"#
	)] %<>% apply(., 2, as.numeric)#
	climate_data %<>% mutate(#
			MinTemp = TMIN/10, # convert tenths of Celcius to Celsius#
			MaxTemp = TMAX/10, # convert tenths of Celcius to Celsius#
			Precip = PRCP/100, # convert PRCP (in tenths of mm) to cm#
			Date = as.Date(as.character(DATE), "%Y%m%d")#
		)#
	# replace NAs again just in case#
	climate_data[,c("MinTemp","MaxTemp","Precip")] %<>% apply(., 2, NA_Function)#
	# replace NA for precip#
	climate_data$Precip[which(climate_data$Precip < 0)] <- NA#
	return(climate_data)#
}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
climate_data <- mergeClimateFiles(climate_file_names)
setwd('/Users/KSauby/Documents/Projects')
setwd("./dataproc")#
#setwd("./modresproc")#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
# list of climate files to fix#
climate_file_names <- c("NOAA.ApalachicolaAirport", "NOAA.ApalachicolaAirport1", "NOAA.Bloxham", "NOAA.Bristol2", "NOAA.Callaway03", "NOAA.Callaway06S", "NOAA.Chipley", "NOAA.Clarksville2N", "NOAA.CrestviewBobSikesAirport", "NOAA.DeFuniakSprings", "NOAA.Destin1", "NOAA.DestinFortWaltonBeach", "NOAA.Freeport34", "NOAA.Freeport40SSW", "NOAA.Freeport44", "NOAA.Hosford27", "NOAA.Marianna7NE", "NOAA.NavalLiveOaks", "NOAA.NWFLBeaches", "NOAA.PanamaCity", "NOAA.PanamaCityBayCoAirport", "NOAA.PanamaCityBeach03", "NOAA.PanamaCityBeach12ESE", "NOAA.PensacolaForest", "NOAA.PensacolaRegionalAirport", "NOAA.PortStJoe06", "NOAA.PortStJoe81", "NOAA.Quincy3SSW", "NOAA.Sumatra", "NOAA.Telogia", "NOAA.ValparaisoEglinAFB", "NOAA.Vernon106", "NOAA.WestPensacola109", "NOAA.Wewahitchka", "NOAA.Wewahitchka16", "NOAA.Wilma", "NOAA.WoodruffDam", "NOAA.Bellview17", "NOAA.Pensacola92", "NOAA.MiramarBeach95", "NOAA.InletBeach07", "NOAA.PanamaCityBeach59", "NOAA.Apalachicola08WNW", "NOAA.NewHope", "NOAA.Destin15")#
#
wstations <- ghcnd.stations.NW.FL.current#
Location_list <- c("BLSP", "HBSP", "MB", "N", "SASP", "TSP")#
#
DegreeDay_list <- c(#
	"UCD.IPM.BLSPDegree.days",#
	"UCD.IPM.HBSPDegree.days",#
	"UCD.IPM.MexicoBeachDegree.days",#
	"UCD.IPM.NokuseDegree.days",#
	"UCD.IPM.SASPDegree.days",#
	"UCD.IPM.SweetwaterDegree.days"#
)#
sites <- Marsico.Florida.data.collection.site.location.summary
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
#' Filter Data by Quality Flag#
#' @description If the quality flag from a NOAA dataset is G, I, K, L, N, O, then change the weather value to "NA"#
#' Table 2 (Quality Flag/Attribute) from the NOAA documentation:#
#' \itemize{#
#'  \item Blank = did not fail any quality assurance check D = failed duplicate check#
#'  \item G = failed gap check#
#'  \item I = failed internal consistency check#
#'  \item K = failed streak/frequent-value check#
#'  \item L = failed check on length of multiday period M = failed mega-consistency check#
#'  \item N = failed naught check#
#'  \item O = failed climatological outlier check#
#' 	}#
#' @param x#
#' @param y#
#' @export#
#
Quality_Flag_Function <- function(x, y){#
	x[which(y=="G" | y=="I" | y=="K" | y=="L" | y=="N" | y=="O")] <- NA#
	return(x)#
}#
#
#' Replace blank values (quality is okay) with "Okay"#
#' @param x#
#' @export#
#
Replace_Blank_w_Okay_Function <- function(x){	#
	x[which(x==" ")] <- "Okay"#
	return(x)#
}#
#
#' Merge Weather Data Files and Format Column Names#
#' @param climate_data#
#' @description For each variable, NOAA uses generic column names "Measurement.Flag", "Quality.Flag", "Source.Flag", "Time.of.Observation" to ensure that the appropriate columns are merged together. This function renames these columns by pasting the name with the name of the variable to which it refers e.g., the "Measurement.Flag" column directly after "PRCP" will become "PRCP.Measurement.Flag" for each weather variable, take weather variable name and paste it to the names of the 4 following columns.#
#' @export#
#
mergeClimateFiles <- function(climate_file_names) {#
	X <- list()#
	for (h in 1:length(climate_file_names)) {#
		# PRCP, TMIN, TMAX name vectors#
		TMIN_vector <- vector()#
		TMAX_vector <- vector()#
		PRCP_vector <- vector()#
		# pull climate file#
		Y <- eval(parse(text=climate_file_names[h]))#
		X[[h]] <- list()#
		# select weather station info to keep#
		X[[h]][[1]] <- Y %>% select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)#
		# counter for weather variable (have to count because not all files have all weather variables)#
		k=2 # start at 2 because weather station info goes in [[1]]#
		# fix PRCP flag column names#
		if ("PRCP" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="PRCP")) : #
				(which(colnames(Y)=="PRCP")+4)]#
			for (i in 1:4) {#
				PRCP_vector[i] <- paste(#
					"PRCP", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="PRCP") #
							+ i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- PRCP_vector#
			k <- k + 1#
		}#
		# fix TMIN flag column names#
		if ("TMIN" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMIN")) : #
				(which(colnames(Y)=="TMIN")+4)]#
			for (i in 1:4) {#
				TMIN_vector[i] <- paste(#
					"TMIN", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMIN") + i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- TMIN_vector#
			k <- k + 1#
		}#
		# fix TMAX flag column names#
		if ("TMAX" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMAX")) : #
				(which(colnames(Y)=="TMAX")+4)]#
			for (i in 1:4) {#
				TMAX_vector[i] <- paste(#
					"TMAX", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMAX") + i])#
					), #
					"Flag", #
					sep="."#
				)		#
			}#
			names(X[[h]][[k]])[2:5] <- TMAX_vector#
		}#
	}#
	# merge list of lists of lists#
	data.array2 <- list()#
	for (i in 1:length(unique(climate_file_names))) {#
		data.array2[[i]] = as.data.frame(#
			mapply(#
				cbind, #
				unlist(#
					X[[i]], #
					recursive=F#
				)#
			)#
		)#
	}	#
	do.call(rbind.fill, data.array2)#
}#
#
#' Filter data by quality#
#' @param climate_data#
#' @description Replace data with NA if it is of questionable quality.#
#' \itemize{ #
#' 		\item Filter data by quality#
#' 		\itemize{#
#' 			\item replace data with NA if it is of questionable quality (see \code{Quality_Flag_Function} function for details)#
#' 			\item replace blank values (quality is okay) with "Okay"#
#' 			\item Replace -999 and blanks with NAs#
#' 		}#
#' }#
#' @export#
#
filterClimateDataByQuality <- function(climate_data) {#
	climate_data$PRCP <- with(#
		climate_data, #
		Quality_Flag_Function(PRCP, PRCP.Quality.Flag)#
	)#
	climate_data$TMIN <- with(#
		climate_data, #
		Quality_Flag_Function(TMIN, TMIN.Quality.Flag)#
	)#
	climate_data$TMAX <- with(#
		climate_data, #
		Quality_Flag_Function(TMAX, TMAX.Quality.Flag)#
	)#
	# replace blank values (quality is okay) with "Okay"#
	climate_data[,c(#
		"PRCP.Quality.Flag", #
		"TMIN.Quality.Flag",#
		"TMAX.Quality.Flag"#
	)] %<>% apply(., 2, Replace_Blank_w_Okay_Function)#
	# Replace -999 and blanks with NAs#
	climate_data[,c(#
		"STATION", #
		"STATION_NAME",#
		"ELEVATION",#
		"LATITUDE",#
		"LONGITUDE",#
		"DATE",#
		"PRCP",#
		"PRCP.Measurement.Flag",#
		"PRCP.Quality.Flag",#
		"PRCP.Source.Flag",#
		"PRCP.Time.Flag",#
		"TMIN",#
		"TMIN.Measurement.Flag",#
		"TMIN.Quality.Flag",#
		"TMIN.Source.Flag",#
		"TMIN.Time.Flag",#
		"TMAX",#
		"TMAX.Measurement.Flag",#
		"TMAX.Quality.Flag",#
		"TMAX.Source.Flag",#
		"TMAX.Time.Flag"#
	)] %<>% apply(., 2, NA_Function)#
	return(climate_data)#
}#
#
#' Format and convert weather data#
#' @param climate_data#
#' @description For each location, compile weather data from the closest weather stations.#
#' \itemize{#
#' 	\item Format/convert weather data#
#' 	\itemize{#
#' 		\item convert tenths of Celcius to Celsius#
#' 		\item convert tenths of Celcius to Celsius#
#' 		\item convert PRCP (in tenths of mm) to cm#
#' 		\item replace NA for precip less than 0#
#' 	}#
#' }#
#' @export#
#
formatconvertClimateData <- function(climate_data) {#
	climate_data[,c(#
		"PRCP",#
		"TMIN",#
		"TMAX"#
	)] %<>% apply(., 2, as.numeric)#
	climate_data %<>% mutate(#
			MinTemp = TMIN/10, # convert tenths of Celcius to Celsius#
			MaxTemp = TMAX/10, # convert tenths of Celcius to Celsius#
			Precip = PRCP/100, # convert PRCP (in tenths of mm) to cm#
			Date = as.Date(as.character(DATE), "%Y%m%d")#
		)#
	# replace NAs again just in case#
	climate_data[,c("MinTemp","MaxTemp","Precip")] %<>% apply(., 2, NA_Function)#
	# replace NA for precip#
	climate_data$Precip[which(climate_data$Precip < 0)] <- NA#
	return(climate_data)#
}#
#
#' Find closest weather stations to each sampling location#
#' @description For each location, compile weather data from the closest weather stations.#
#' @param sites List of sampling locations with x, y coordinates.#
#' @param climate_data#
#' @param Distance Radius (km) within which to look for climate stations for a particular location. Defaults to 85 kilometers.#
#' @export#
#
findClosestWeatherStations <- function(sites, climate_data, Distance=85) {#
	# merge sampling locations and weather station locations to calculate distance matrix (all pairwise distances among points)#
	A <- sites %>%#
		dplyr::select(Location.name, Latitude, Longitude) %>%#
		rbind.fill(dplyr::select(wstations, Name, Latitude, Longitude))#
	# first convert sampling locations and weather station coordinates to UTM#
	coordinates(A) <- c("Longitude", "Latitude")#
	proj4string(A) <- CRS("+proj=longlat +datum=WGS84")  ## for example#
	# then calculate dist matrix (which will now be in m)#
	A %<>% spTransform(CRS("+proj=utm +zone=16 ellps=WGS84"))#
	# convert coordinates back to numeric#
	A <- as.data.frame(cbind(A$Name, A@coords))#
	names(A) <- c("Name", "Easting", "Northing")#
	A[,c("Easting", "Northing")] %<>% apply(., 2, as.numeric)#
	# convert coordinate units to km#
	A[,c("Easting", "Northing")] %<>% apply(., 2, function(x) {x/1000})#
	# calculate distance matrix#
	distance_matrix <- as.data.frame(#
		as.matrix(#
			dist(#
				cbind(A$Easting, A$Northing), #
				method="euclidian"#
			)#
		)#
	)#
	# modify distance matrix#
	# 		keep columns 1:6 (correspond to the 6 sampling locations)#
	# 		keep rows 7:170 (correspond to the weather stations)#
	distance_matrix <- distance_matrix[7:134, 1:6]#
	names(distance_matrix) <- Location_list#
	# merge distance matrix with weather station info#
	B <- dplyr::select(#
		wstations, #
		Name, #
		Station.ID, #
		Latitude, #
		Longitude, #
		Precipitation, #
		Temperature, #
		Used_in_Analysis, #
		Sampling_Site, #
		Near_Sampling_Site, #
		Date_Range#
	)#
	distance_matrix %<>% cbind(B)#
	# change distance matrix columns to one column#
	weather_station_info <- reshape2::melt(#
		distance_matrix, #
		id.vars=c(#
			"Name", #
			"Station.ID", #
			"Latitude", #
			"Longitude", #
			"Precipitation", #
			"Temperature", #
			"Used_in_Analysis", #
			"Sampling_Site", #
			"Near_Sampling_Site", #
			"Date_Range"#
		)#
	)#
	names(weather_station_info)[(dim(weather_station_info)[2]-1) : #
		dim(weather_station_info)[2]] <- c("Sampling_Location", "Distance")#
	# standardize Station IDs - remove "GHCND:" if the the ID has it#
	weather_station_info$Station.ID <- gsub(#
		"^.*\\:", "", #
		weather_station_info$Station.ID#
	)#
	climate_data$STATION <- gsub("^.*\\:", "", climate_data$STATION)#
	# SELECT CLOSEST WEATHER STATIONS FOR EACH SAMPLING LOCATION#
	# merge distance data with climate_data#
	climate_data_temp <- weather_station_info %>% #
		dplyr::select(Station.ID, Sampling_Location, Distance) %>%#
		merge(climate_data, by.x="Station.ID", by.y="STATION")#
	BLSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="BLSP" & Distance <= Distance)#
	HBSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="HBSP" & Distance <= Distance) %>% #
		arrange(Date)#
	MB_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="MB" & Distance <= Distance)#
	N_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="N" & Distance <= Distance)#
	SASP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="SASP" & Distance <= Distance)#
	TSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="TSP" & Distance <= Distance)#
	# create list of climate stations per sampling location#
	Dat = list(#
		`climate_data`	= climate_data_temp,#
		`BLSP_stations` = BLSP_stations,#
		`HBSP_stations` = HBSP_stations,#
		`MB_stations` 	= MB_stations,#
		`N_stations` 	= N_stations,#
		`SASP_stations` = SASP_stations,#
		`TSP_stations` 	= TSP_stations#
	)#
	return(Dat)#
}#
#
#' Choose closest weather variable measurement for each Location/Date combo#
#' @description For each date and location, get weather data from the closest available weather station.#
#' @param Datalist Output (list format) from the \code{findClosestWeatherStations} function.#
#' @export#
#
getClimateDataByLocationDate <- function(Datalist) {#
	X <- list()#
	# for each LOCATION#
	for (i in 1:length(Location_list)) {#
		X[[i]] <- list()#
		# pull climate data for that location and merge with station data to get distance from station to sampling location#
		data = eval(parse(text=paste(#
			"Datalist$", #
			Location_list[i], #
			"_stations", #
			sep=""#
		)))#
		# PRECIPITATION#
		P 			<- data %>% filter(!is.na(Precip))#
		X[[i]][[1]] <- as.data.frame(matrix(NA, length(unique(P$Date)), 6))#
		names(X[[i]][[1]]) <- c(#
			"Precip_STATION_NAME", #
			"Precip_STATION", #
			"Precip_STATION_Distance", #
			"Date", #
			"Precip", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(P$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[1]][j, ] = P %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					Precip_STATION_NAME 	= STATION_NAME,#
					Precip_STATION 			= Station.ID,#
					Precip_STATION_Distance = Distance,#
					Date 					= Date[1],#
					Precip 					= Precip#
				)#
		}#
		# MIN TEMPERATURE#
		Min 		<- data %>% filter(!is.na(MinTemp))#
		X[[i]][[2]] <- as.data.frame(matrix(NA, length(unique(Min$Date)), 6))#
		names(X[[i]][[2]]) <- c(#
			"MinTemp_STATION_NAME", #
			"MinTemp_STATION", #
			"MinTemp_STATION_Distance", #
			"Date", #
			"MinTemp", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(Min$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[2]][j, ] = Min %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					MinTemp_STATION_NAME 		= STATION_NAME,#
					MinTemp_STATION 			= Station.ID,#
					MinTemp_STATION_Distance 	= Distance,#
					Date 						= Date,#
					MinTemp 					= MinTemp#
				)#
		}#
		# MAX TEMPERATURE#
		Max <- data %>% filter(!is.na(MaxTemp))#
		X[[i]][[3]] <- as.data.frame(matrix(NA, length(unique(Max$Date)), 6))#
		names(X[[i]][[3]]) <- c(#
			"MaxTemp_STATION_NAME", #
			"MaxTemp_STATION", #
			"MaxTemp_STATION_Distance", #
			"Date", #
			"MaxTemp", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(Max$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[3]][j, ] = Max %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					MaxTemp_STATION_NAME 		= STATION_NAME,#
					MaxTemp_STATION 			= Station.ID,#
					MaxTemp_STATION_Distance 	= Distance,#
					Date 						= Date,#
					MaxTemp 					= MaxTemp#
				)#
		}#
		X[[i]][[1]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[2]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[3]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[1]]$Location = Location_list[i]#
		X[[i]][[2]]$Location = Location_list[i]#
		X[[i]][[3]]$Location = Location_list[i]#
	}#
	# merge list of lists of lists#
	data.array2 <- list()#
	# for each density#
	for (i in 1:length(Location_list)) {#
	# for (i in 1:length(unique(patch_data$density))) {#
		# compress list of statistics to dataframe#
		data.array2[[i]] = join_all(X[[i]], by="Date", type="full")#
	}	#
	climate_data = do.call(rbind.fill, data.array2)#
}#
#
#' Calculate Growing Degree Days#
#' @description I used this website to calculate growing degree days: http://www.ipm.ucdavis.edu/WEATHER/ddretrievetext.html. This function merges them together with the \code{climate_data} dataframe.#
#' @param DegreeDay_list list of separate Degree Day files#
#' @param climate_data climate data#
#' @export#
#
calculateDegreeDays <- function(DegreeDay_list, climate_data) {#
	X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)#
	DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)#
	names(DegreeDays.merged)[2:3] <- c("MinTemp", "MaxTemp")#
	return(DegreeDays.merged)#
}
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
wstations$Start_Date <- sub(" .*", "", #
		wstations$Date_Range)#
	wstations$End_Date <- sub(".* ", "", #
		wstations$Date_Range)#
	# filter dates to study dates#
	wstations %<>%#
		filter(Start_Date <= "2014-01-17", End_Date >= "2008-01-20") %>%#
		# merge with list of weather stations for which start/end date is not known#
		rbind(filter(wstations, Start_Date == "", End_Date >= ""))#
	#############################################################################
	# MODIFY INDIVIDUAL WEATHER STATION FILES#
	#############################################################################
	climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality %>%#
		formatconvertClimateData#
	#---------------------------- Restrict start and end dates --------------- ##
	climate_data %<>% filter(Date <= "2014-01-17", Date >= "2008-01-20")#
	Datalist <- findClosestWeatherStations(sites, climate_data, Distance=85) #
	climate_data <- getClimateDataByLocationDate(Datalist)
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data <- mergeClimateFiles(climate_file_names)
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
# list of climate files to fix#
climate_file_names <- c("NOAA.ApalachicolaAirport", "NOAA.ApalachicolaAirport1", "NOAA.Bloxham", "NOAA.Bristol2", "NOAA.Callaway03", "NOAA.Callaway06S", "NOAA.Chipley", "NOAA.Clarksville2N", "NOAA.CrestviewBobSikesAirport", "NOAA.DeFuniakSprings", "NOAA.Destin1", "NOAA.DestinFortWaltonBeach", "NOAA.Freeport34", "NOAA.Freeport40SSW", "NOAA.Freeport44", "NOAA.Hosford27", "NOAA.Marianna7NE", "NOAA.NavalLiveOaks", "NOAA.NWFLBeaches", "NOAA.PanamaCity", "NOAA.PanamaCityBayCoAirport", "NOAA.PanamaCityBeach03", "NOAA.PanamaCityBeach12ESE", "NOAA.PensacolaForest", "NOAA.PensacolaRegionalAirport", "NOAA.PortStJoe06", "NOAA.PortStJoe81", "NOAA.Quincy3SSW", "NOAA.Sumatra", "NOAA.Telogia", "NOAA.ValparaisoEglinAFB", "NOAA.Vernon106", "NOAA.WestPensacola109", "NOAA.Wewahitchka", "NOAA.Wewahitchka16", "NOAA.Wilma", "NOAA.WoodruffDam", "NOAA.Bellview17", "NOAA.Pensacola92", "NOAA.MiramarBeach95", "NOAA.InletBeach07", "NOAA.PanamaCityBeach59", "NOAA.Apalachicola08WNW", "NOAA.NewHope", "NOAA.Destin15")
str(NOAA.ApalachicolaAirport)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X <- list()#
	for (h in 1:length(climate_file_names)) {#
		# PRCP, TMIN, TMAX name vectors#
		TMIN_vector <- vector()#
		TMAX_vector <- vector()#
		PRCP_vector <- vector()#
		# pull climate file#
		Y <- eval(parse(text=climate_file_names[h]))#
		X[[h]] <- list()#
		# select weather station info to keep#
		X[[h]][[1]] <- Y %>% select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)#
		# counter for weather variable (have to count because not all files have all weather variables)#
		k=2 # start at 2 because weather station info goes in [[1]]#
		# fix PRCP flag column names#
		if ("PRCP" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="PRCP")) : #
				(which(colnames(Y)=="PRCP")+4)]#
			for (i in 1:4) {#
				PRCP_vector[i] <- paste(#
					"PRCP", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="PRCP") #
							+ i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- PRCP_vector#
			k <- k + 1#
		}#
		# fix TMIN flag column names#
		if ("TMIN" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMIN")) : #
				(which(colnames(Y)=="TMIN")+4)]#
			for (i in 1:4) {#
				TMIN_vector[i] <- paste(#
					"TMIN", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMIN") + i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- TMIN_vector#
			k <- k + 1#
		}#
		# fix TMAX flag column names#
		if ("TMAX" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMAX")) : #
				(which(colnames(Y)=="TMAX")+4)]#
			for (i in 1:4) {#
				TMAX_vector[i] <- paste(#
					"TMAX", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMAX") + i])#
					), #
					"Flag", #
					sep="."#
				)		#
			}#
			names(X[[h]][[k]])[2:5] <- TMAX_vector#
		}#
	}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X <- list()
h=1
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
TMIN_vector <- vector()#
		TMAX_vector <- vector()#
		PRCP_vector <- vector()#
		# pull climate file#
		Y <- eval(parse(text=climate_file_names[h]))
head(Y)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X[[h]] <- list()#
		# select weather station info to keep#
		X[[h]][[1]] <- Y %>% select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X[[h]][[1]] <- Y %>% dplyr::select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X <- list()#
	for (h in 1:length(climate_file_names)) {#
		# PRCP, TMIN, TMAX name vectors#
		TMIN_vector <- vector()#
		TMAX_vector <- vector()#
		PRCP_vector <- vector()#
		# pull climate file#
		Y <- eval(parse(text=climate_file_names[h]))#
		X[[h]] <- list()#
		# select weather station info to keep#
		X[[h]][[1]] <- Y %>% dplyr::select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)#
		# counter for weather variable (have to count because not all files have all weather variables)#
		k=2 # start at 2 because weather station info goes in [[1]]#
		# fix PRCP flag column names#
		if ("PRCP" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="PRCP")) : #
				(which(colnames(Y)=="PRCP")+4)]#
			for (i in 1:4) {#
				PRCP_vector[i] <- paste(#
					"PRCP", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="PRCP") #
							+ i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- PRCP_vector#
			k <- k + 1#
		}#
		# fix TMIN flag column names#
		if ("TMIN" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMIN")) : #
				(which(colnames(Y)=="TMIN")+4)]#
			for (i in 1:4) {#
				TMIN_vector[i] <- paste(#
					"TMIN", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMIN") + i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- TMIN_vector#
			k <- k + 1#
		}#
		# fix TMAX flag column names#
		if ("TMAX" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMAX")) : #
				(which(colnames(Y)=="TMAX")+4)]#
			for (i in 1:4) {#
				TMAX_vector[i] <- paste(#
					"TMAX", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMAX") + i])#
					), #
					"Flag", #
					sep="."#
				)		#
			}#
			names(X[[h]][[k]])[2:5] <- TMAX_vector#
		}#
	}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
#' Filter Data by Quality Flag#
#' @description If the quality flag from a NOAA dataset is G, I, K, L, N, O, then change the weather value to "NA"#
#' Table 2 (Quality Flag/Attribute) from the NOAA documentation:#
#' \itemize{#
#'  \item Blank = did not fail any quality assurance check D = failed duplicate check#
#'  \item G = failed gap check#
#'  \item I = failed internal consistency check#
#'  \item K = failed streak/frequent-value check#
#'  \item L = failed check on length of multiday period M = failed mega-consistency check#
#'  \item N = failed naught check#
#'  \item O = failed climatological outlier check#
#' 	}#
#' @param x#
#' @param y#
#' @export#
#' @importFrom dplyr select#
#
Quality_Flag_Function <- function(x, y){#
	x[which(y=="G" | y=="I" | y=="K" | y=="L" | y=="N" | y=="O")] <- NA#
	return(x)#
}#
#
#' Replace blank values (quality is okay) with "Okay"#
#' @param x#
#' @export#
#
Replace_Blank_w_Okay_Function <- function(x){	#
	x[which(x==" ")] <- "Okay"#
	return(x)#
}#
#
#' Merge Weather Data Files and Format Column Names#
#' @param climate_data#
#' @description For each variable, NOAA uses generic column names "Measurement.Flag", "Quality.Flag", "Source.Flag", "Time.of.Observation" to ensure that the appropriate columns are merged together. This function renames these columns by pasting the name with the name of the variable to which it refers e.g., the "Measurement.Flag" column directly after "PRCP" will become "PRCP.Measurement.Flag" for each weather variable, take weather variable name and paste it to the names of the 4 following columns.#
#' @export#
#
mergeClimateFiles <- function(climate_file_names) {#
	X <- list()#
	for (h in 1:length(climate_file_names)) {#
		# PRCP, TMIN, TMAX name vectors#
		TMIN_vector <- vector()#
		TMAX_vector <- vector()#
		PRCP_vector <- vector()#
		# pull climate file#
		Y <- eval(parse(text=climate_file_names[h]))#
		X[[h]] <- list()#
		# select weather station info to keep#
		X[[h]][[1]] <- Y %>% dplyr::select(#
			STATION, #
			STATION_NAME, #
			ELEVATION, #
			LATITUDE, #
			LONGITUDE, #
			DATE#
		)#
		# counter for weather variable (have to count because not all files have all weather variables)#
		k=2 # start at 2 because weather station info goes in [[1]]#
		# fix PRCP flag column names#
		if ("PRCP" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="PRCP")) : #
				(which(colnames(Y)=="PRCP")+4)]#
			for (i in 1:4) {#
				PRCP_vector[i] <- paste(#
					"PRCP", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="PRCP") #
							+ i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- PRCP_vector#
			k <- k + 1#
		}#
		# fix TMIN flag column names#
		if ("TMIN" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMIN")) : #
				(which(colnames(Y)=="TMIN")+4)]#
			for (i in 1:4) {#
				TMIN_vector[i] <- paste(#
					"TMIN", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMIN") + i])#
					), #
					"Flag", #
					sep="."#
				)#
			}#
			names(X[[h]][[k]])[2:5] <- TMIN_vector#
			k <- k + 1#
		}#
		# fix TMAX flag column names#
		if ("TMAX" %in% names(Y)) {#
			X[[h]][[k]] <- Y[, (which(colnames(Y)=="TMAX")) : #
				(which(colnames(Y)=="TMAX")+4)]#
			for (i in 1:4) {#
				TMAX_vector[i] <- paste(#
					"TMAX", #
					sub(#
						"(.*?)[.].*", "\\1", #
						names(X[[h]][[k]][which(colnames(X[[h]][[k]])=="TMAX") + i])#
					), #
					"Flag", #
					sep="."#
				)		#
			}#
			names(X[[h]][[k]])[2:5] <- TMAX_vector#
		}#
	}#
	# merge list of lists of lists#
	data.array2 <- list()#
	for (i in 1:length(unique(climate_file_names))) {#
		data.array2[[i]] = as.data.frame(#
			mapply(#
				cbind, #
				unlist(#
					X[[i]], #
					recursive=F#
				)#
			)#
		)#
	}	#
	do.call(rbind.fill, data.array2)#
}#
#
#' Filter data by quality#
#' @param climate_data#
#' @description Replace data with NA if it is of questionable quality.#
#' \itemize{ #
#' 		\item Filter data by quality#
#' 		\itemize{#
#' 			\item replace data with NA if it is of questionable quality (see \code{Quality_Flag_Function} function for details)#
#' 			\item replace blank values (quality is okay) with "Okay"#
#' 			\item Replace -999 and blanks with NAs#
#' 		}#
#' }#
#' @export#
#
filterClimateDataByQuality <- function(climate_data) {#
	climate_data$PRCP <- with(#
		climate_data, #
		Quality_Flag_Function(PRCP, PRCP.Quality.Flag)#
	)#
	climate_data$TMIN <- with(#
		climate_data, #
		Quality_Flag_Function(TMIN, TMIN.Quality.Flag)#
	)#
	climate_data$TMAX <- with(#
		climate_data, #
		Quality_Flag_Function(TMAX, TMAX.Quality.Flag)#
	)#
	# replace blank values (quality is okay) with "Okay"#
	climate_data[,c(#
		"PRCP.Quality.Flag", #
		"TMIN.Quality.Flag",#
		"TMAX.Quality.Flag"#
	)] %<>% apply(., 2, Replace_Blank_w_Okay_Function)#
	# Replace -999 and blanks with NAs#
	climate_data[,c(#
		"STATION", #
		"STATION_NAME",#
		"ELEVATION",#
		"LATITUDE",#
		"LONGITUDE",#
		"DATE",#
		"PRCP",#
		"PRCP.Measurement.Flag",#
		"PRCP.Quality.Flag",#
		"PRCP.Source.Flag",#
		"PRCP.Time.Flag",#
		"TMIN",#
		"TMIN.Measurement.Flag",#
		"TMIN.Quality.Flag",#
		"TMIN.Source.Flag",#
		"TMIN.Time.Flag",#
		"TMAX",#
		"TMAX.Measurement.Flag",#
		"TMAX.Quality.Flag",#
		"TMAX.Source.Flag",#
		"TMAX.Time.Flag"#
	)] %<>% apply(., 2, NA_Function)#
	return(climate_data)#
}#
#
#' Format and convert weather data#
#' @param climate_data#
#' @description For each location, compile weather data from the closest weather stations.#
#' \itemize{#
#' 	\item Format/convert weather data#
#' 	\itemize{#
#' 		\item convert tenths of Celcius to Celsius#
#' 		\item convert tenths of Celcius to Celsius#
#' 		\item convert PRCP (in tenths of mm) to cm#
#' 		\item replace NA for precip less than 0#
#' 	}#
#' }#
#' @export#
#
formatconvertClimateData <- function(climate_data) {#
	climate_data[,c(#
		"PRCP",#
		"TMIN",#
		"TMAX"#
	)] %<>% apply(., 2, as.numeric)#
	climate_data %<>% mutate(#
			MinTemp = TMIN/10, # convert tenths of Celcius to Celsius#
			MaxTemp = TMAX/10, # convert tenths of Celcius to Celsius#
			Precip = PRCP/100, # convert PRCP (in tenths of mm) to cm#
			Date = as.Date(as.character(DATE), "%Y%m%d")#
		)#
	# replace NAs again just in case#
	climate_data[,c("MinTemp","MaxTemp","Precip")] %<>% apply(., 2, NA_Function)#
	# replace NA for precip#
	climate_data$Precip[which(climate_data$Precip < 0)] <- NA#
	return(climate_data)#
}#
#
#' Find closest weather stations to each sampling location#
#' @description For each location, compile weather data from the closest weather stations.#
#' @param sites List of sampling locations with x, y coordinates.#
#' @param climate_data#
#' @param Distance Radius (km) within which to look for climate stations for a particular location. Defaults to 85 kilometers.#
#' @export#
#
findClosestWeatherStations <- function(sites, climate_data, Distance=85) {#
	# merge sampling locations and weather station locations to calculate distance matrix (all pairwise distances among points)#
	A <- sites %>%#
		dplyr::select(Location.name, Latitude, Longitude) %>%#
		rbind.fill(dplyr::select(wstations, Name, Latitude, Longitude))#
	# first convert sampling locations and weather station coordinates to UTM#
	coordinates(A) <- c("Longitude", "Latitude")#
	proj4string(A) <- CRS("+proj=longlat +datum=WGS84")  ## for example#
	# then calculate dist matrix (which will now be in m)#
	A %<>% spTransform(CRS("+proj=utm +zone=16 ellps=WGS84"))#
	# convert coordinates back to numeric#
	A <- as.data.frame(cbind(A$Name, A@coords))#
	names(A) <- c("Name", "Easting", "Northing")#
	A[,c("Easting", "Northing")] %<>% apply(., 2, as.numeric)#
	# convert coordinate units to km#
	A[,c("Easting", "Northing")] %<>% apply(., 2, function(x) {x/1000})#
	# calculate distance matrix#
	distance_matrix <- as.data.frame(#
		as.matrix(#
			dist(#
				cbind(A$Easting, A$Northing), #
				method="euclidian"#
			)#
		)#
	)#
	# modify distance matrix#
	# 		keep columns 1:6 (correspond to the 6 sampling locations)#
	# 		keep rows 7:170 (correspond to the weather stations)#
	distance_matrix <- distance_matrix[7:134, 1:6]#
	names(distance_matrix) <- Location_list#
	# merge distance matrix with weather station info#
	B <- dplyr::select(#
		wstations, #
		Name, #
		Station.ID, #
		Latitude, #
		Longitude, #
		Precipitation, #
		Temperature, #
		Used_in_Analysis, #
		Sampling_Site, #
		Near_Sampling_Site, #
		Date_Range#
	)#
	distance_matrix %<>% cbind(B)#
	# change distance matrix columns to one column#
	weather_station_info <- reshape2::melt(#
		distance_matrix, #
		id.vars=c(#
			"Name", #
			"Station.ID", #
			"Latitude", #
			"Longitude", #
			"Precipitation", #
			"Temperature", #
			"Used_in_Analysis", #
			"Sampling_Site", #
			"Near_Sampling_Site", #
			"Date_Range"#
		)#
	)#
	names(weather_station_info)[(dim(weather_station_info)[2]-1) : #
		dim(weather_station_info)[2]] <- c("Sampling_Location", "Distance")#
	# standardize Station IDs - remove "GHCND:" if the the ID has it#
	weather_station_info$Station.ID <- gsub(#
		"^.*\\:", "", #
		weather_station_info$Station.ID#
	)#
	climate_data$STATION <- gsub("^.*\\:", "", climate_data$STATION)#
	# SELECT CLOSEST WEATHER STATIONS FOR EACH SAMPLING LOCATION#
	# merge distance data with climate_data#
	climate_data_temp <- weather_station_info %>% #
		dplyr::select(Station.ID, Sampling_Location, Distance) %>%#
		merge(climate_data, by.x="Station.ID", by.y="STATION")#
	BLSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="BLSP" & Distance <= Distance)#
	HBSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="HBSP" & Distance <= Distance) %>% #
		arrange(Date)#
	MB_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="MB" & Distance <= Distance)#
	N_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="N" & Distance <= Distance)#
	SASP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="SASP" & Distance <= Distance)#
	TSP_stations <- climate_data_temp %>% #
		filter(Sampling_Location=="TSP" & Distance <= Distance)#
	# create list of climate stations per sampling location#
	Dat = list(#
		`climate_data`	= climate_data_temp,#
		`BLSP_stations` = BLSP_stations,#
		`HBSP_stations` = HBSP_stations,#
		`MB_stations` 	= MB_stations,#
		`N_stations` 	= N_stations,#
		`SASP_stations` = SASP_stations,#
		`TSP_stations` 	= TSP_stations#
	)#
	return(Dat)#
}#
#
#' Choose closest weather variable measurement for each Location/Date combo#
#' @description For each date and location, get weather data from the closest available weather station.#
#' @param Datalist Output (list format) from the \code{findClosestWeatherStations} function.#
#' @export#
#
getClimateDataByLocationDate <- function(Datalist) {#
	X <- list()#
	# for each LOCATION#
	for (i in 1:length(Location_list)) {#
		X[[i]] <- list()#
		# pull climate data for that location and merge with station data to get distance from station to sampling location#
		data = eval(parse(text=paste(#
			"Datalist$", #
			Location_list[i], #
			"_stations", #
			sep=""#
		)))#
		# PRECIPITATION#
		P 			<- data %>% filter(!is.na(Precip))#
		X[[i]][[1]] <- as.data.frame(matrix(NA, length(unique(P$Date)), 6))#
		names(X[[i]][[1]]) <- c(#
			"Precip_STATION_NAME", #
			"Precip_STATION", #
			"Precip_STATION_Distance", #
			"Date", #
			"Precip", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(P$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[1]][j, ] = P %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					Precip_STATION_NAME 	= STATION_NAME,#
					Precip_STATION 			= Station.ID,#
					Precip_STATION_Distance = Distance,#
					Date 					= Date[1],#
					Precip 					= Precip#
				)#
		}#
		# MIN TEMPERATURE#
		Min 		<- data %>% filter(!is.na(MinTemp))#
		X[[i]][[2]] <- as.data.frame(matrix(NA, length(unique(Min$Date)), 6))#
		names(X[[i]][[2]]) <- c(#
			"MinTemp_STATION_NAME", #
			"MinTemp_STATION", #
			"MinTemp_STATION_Distance", #
			"Date", #
			"MinTemp", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(Min$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[2]][j, ] = Min %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					MinTemp_STATION_NAME 		= STATION_NAME,#
					MinTemp_STATION 			= Station.ID,#
					MinTemp_STATION_Distance 	= Distance,#
					Date 						= Date,#
					MinTemp 					= MinTemp#
				)#
		}#
		# MAX TEMPERATURE#
		Max <- data %>% filter(!is.na(MaxTemp))#
		X[[i]][[3]] <- as.data.frame(matrix(NA, length(unique(Max$Date)), 6))#
		names(X[[i]][[3]]) <- c(#
			"MaxTemp_STATION_NAME", #
			"MaxTemp_STATION", #
			"MaxTemp_STATION_Distance", #
			"Date", #
			"MaxTemp", #
			"Location"#
		)#
		# for each DATE#
		for (j in 1:length(unique(Max$Date))) {#
			# pull climate data associated with that location#
			X[[i]][[3]][j, ] = Max %>% #
				filter(Date == unique(Date)[j]) %>%#
				filter(Distance == min(Distance)) %>%#
				summarise(#
					MaxTemp_STATION_NAME 		= STATION_NAME,#
					MaxTemp_STATION 			= Station.ID,#
					MaxTemp_STATION_Distance 	= Distance,#
					Date 						= Date,#
					MaxTemp 					= MaxTemp#
				)#
		}#
		X[[i]][[1]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[2]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[3]]$Date %<>% as.Date(origin="1970-01-01")#
		X[[i]][[1]]$Location = Location_list[i]#
		X[[i]][[2]]$Location = Location_list[i]#
		X[[i]][[3]]$Location = Location_list[i]#
	}#
	# merge list of lists of lists#
	data.array2 <- list()#
	# for each density#
	for (i in 1:length(Location_list)) {#
	# for (i in 1:length(unique(patch_data$density))) {#
		# compress list of statistics to dataframe#
		data.array2[[i]] = join_all(X[[i]], by="Date", type="full")#
	}	#
	climate_data = do.call(rbind.fill, data.array2)#
}#
#
#' Calculate Growing Degree Days#
#' @description I used this website to calculate growing degree days: http://www.ipm.ucdavis.edu/WEATHER/ddretrievetext.html. This function merges them together with the \code{climate_data} dataframe.#
#' @param DegreeDay_list list of separate Degree Day files#
#' @param climate_data climate data#
#' @export#
#
calculateDegreeDays <- function(DegreeDay_list, climate_data) {#
	X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)#
	DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)#
	names(DegreeDays.merged)[2:3] <- c("MinTemp", "MaxTemp")#
	return(DegreeDays.merged)#
}
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality %>%#
		formatconvertClimateData
library(dataproc)
climate_data <- mergeClimateFiles(climate_file_names) %>%#
		filterClimateDataByQuality %>%#
		formatconvertClimateData
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data %<>% filter(Date <= "2014-01-17", Date >= "2008-01-20")#
	Datalist <- findClosestWeatherStations(sites, climate_data, Distance=85) #
	climate_data <- getClimateDataByLocationDate(Datalist)
head(climate_data)
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
calculateDegreeDays %<>% climate_data
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data %<>% calculateDegreeDays
str(climate_data)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)#
	DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	# DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)#
	names(DegreeDays.merged)[2:3] <- c("MinTemp", "MaxTemp")
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
calculateDegreeDays <- function(climate_data, DegreeDay_list) {#
	X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)#
	DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	# DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)#
	names(DegreeDays.merged)[2:3] <- c("MinTemp", "MaxTemp")#
	return(DegreeDays.merged)#
}
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data %<>% calculateDegreeDays
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
calculateDegreeDays <- function(climate_data, DegreeDay_list=DegreeDay_list) {#
	X <- list()#
	for (i in 1:length(DegreeDay_list)) {#
		X[[i]] <- eval(parse(text=DegreeDay_list[i]))#
	}#
	DegreeDays <- do.call(rbind.fill, X)#
	DegreeDays$Date %<>% as.Date("%m/%d/%y")#
	DegreeDays.unique = unique(DegreeDays[, 1:4])#
	# DegreeDays %>% filter(Date=="2014-01-17")#
	DegreeDays.merged = merge(#
		DegreeDays.unique, #
		climate_data, #
		by.x=c("Date", "Temp.min", "Temp.max"), #
		by.y=c("Date", "MinTemp", "MaxTemp"), #
		all.y=T#
	)#
	names(DegreeDays.merged)[2:3] <- c("MinTemp", "MaxTemp")#
	return(DegreeDays.merged)#
}
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data %<>% calculateDegreeDays
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
climate_data %<>% calculateDegreeDays(DegreeDay_list)
head(climate_data)
setwd('/Users/KSauby/Documents/Dropbox/gradschool/Research/Projects/marsico-time-series/munge')
temp <- calculateClimateVariables(timeseries_all_surveys, climate_data, calculate_dates="TRUE")
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
calculateClimateVariables <- function(x, climate_data, calculate_dates="TRUE") {#
	climate_data %<>% renameLocations#
	# create list of dates#
	if (calculate_dates=="TRUE") {#
		# get unique Date and DaysSincePrevSurvey combos#
		A = as.data.frame(x) %>%#
			group_by(Date, Location, Species) %>%#
			# to make sure that this group all share the same Previous_Survey_Date Date#
			summarise(PrevSurvD = paste(Maximum(Previous_Survey_Date))) %>%#
			as.data.frame %>%#
			arrange(Location, Date)#
		#----------------- Fill in Missing Previous Survey Date for Survey 1 --##
		# Generate fake "PrevSurvD" based on the average number of days #
		#		between surveys#
		A$PrevSurvD[A$PrevSurvD=="NA" & year(A$Date)==2009] <- #
			as.character(A$Date[A$PrevSurvD=="NA" & year(A$Date)==2009] - #
			round(mean(x$DaysSincePrevSurvey, na.rm=T)))#
		A 			%<>% filter(PrevSurvD!="NA")#
		A$PrevSurvD %<>% as.Date("%Y-%m-%d")#
	} else {#
		A %<>% mutate(#
			# previous dates#
			PrevSurvD = as.Date(c(NA, Date[-length(Date)]), origin="1970-01-01")#
		)#
	}#
	# prep dataframe for addition of of climate variables#
	Names <- c(#
		"Daily_Precip_mean",#
		"Daily_Precip_SD",#
		"Perc_Days_w_Rain",#
		"Perc_Days_w_Freeze",#
		"mean_Max_Temp",#
		"sd_Max_Temp",#
		"MeanDegreeDay",#
		"Mean_Consecutive_Days_w_Rain",#
		"Max_Consecutive_Days_w_Rain",#
		"sd_Consecutive_Days_w_Rain",#
		"Mean_Consecutive_Drought_Days",#
		"Max_Consecutive_Drought_Days",#
		"sd_Consecutive_Drought_Days",#
		"Mean_Consecutive_Freezing_Days",#
		"Max_Consecutive_Freezing_Days",#
		"sd_Consecutive_Freezing_Days"#
	)#
	A1 <- A %>% cbind(#
		as.data.frame(#
			matrix(#
				nrow=dim(A)[1], #
				ncol=length(Names),#
				data=NA#
			)#
		)#
	)#
	names(A)[((dim(A)[2] + 1) : (dim(A)[2] + length(Names))] <- Names#
	# for new plants, assign previous visit based on previous visit to location#
	# calculate climate variables#
	for (i in 1:dim(A)[1]) {#
		# subset data by time period and location#
		#		date is equal to or greater than previous survey date#
		temp = climate_data[which(#
			climate_data$Date >= A$PrevSurvD[i] & #
			climate_data$Date < A$Date[i] & # date is less than current date#
			climate_data$Location==A$Location[i]#
		), ] # and pull data for correct location #
		# Climate Variable Calculations#
		A$Daily_Precip_mean[i] 	<- mean(temp$Precip, na.rm=T)#
		A$Daily_Precip_SD[i] 	<- sd(temp$Precip, na.rm=T)#
		#		length of precip > 0 / length of precip != NA#
		A$Perc_Days_w_Rain[i] 	<- #
			length(filter(temp, Precip>0)$Precip) / length(!is.na(temp$Precip))#
		#		length of MinTemp <= 0 / length of MinTemp != NA#
		A$Perc_Days_w_Freeze[i] <- #
			length(filter(temp, MinTemp<=0)$MinTemp) / #
			length(!is.na(temp$MinTemp))#
		A$mean_Max_Temp[i] 		<- mean(temp$MaxTemp, na.rm=T)#
		A$sd_Max_Temp[i] 		<- sd(temp$MaxTemp, na.rm=T)#
		A$MeanDegreeDay[i] 		<- mean(temp$Daily.DD, na.rm=T)#
		# consecutive days with rain#
		# count identical consecutive values#
		r <- rle(temp$Precip_Presence)#
		# get lengths for value=1#
		r1 <- r$length[r$values == 1]#
		A$Mean_Consecutive_Days_w_Rain[i] 	<- mean(r1, na.rm=T)#
		A$Max_Consecutive_Days_w_Rain[i] 	<- max(r1, na.rm=T)#
		A$sd_Consecutive_Days_w_Rain[i] 	<- sd(r1, na.rm=T)#
		# consecutive drought days#
		r0 <- r$length[r$values == 0]#
		A$Mean_Consecutive_Drought_Days[i] 	<- mean(r0, na.rm=T)#
		A$Max_Consecutive_Drought_Days[i] 	<- max(r0, na.rm=T)#
		A$sd_Consecutive_Drought_Days[i] 	<- sd(r0, na.rm=T)#
		# Consecutive Freezing Days#
		# count identical consecutive values#
		r <- rle(temp$MinTemp_lt_equal_0)#
		# get lengths for value=1#
		r1 <- r$length[r$values == 1]#
		#	if there was at least one freezing day:#
		if (length(r1) > 0) {#
			A$Mean_Consecutive_Freezing_Days[i] 	<- mean(r1, na.rm=T)#
			A$Max_Consecutive_Freezing_Days[i] 		<- max(r1, na.rm=T)#
			# 	calculate sd if there is more than one value; otherwise sd=0#
			A$sd_Consecutive_Freezing_Days[i] 		<- ifelse(#
				length(r1)>1, #
				sd(r$length[r$values == 1], na.rm=T),#
				0#
			)#
		} else {#
			A$Mean_Consecutive_Freezing_Days[i] 	<- 0#
			A$Max_Consecutive_Freezing_Days[i] 		<- 0#
			A$sd_Consecutive_Freezing_Days[i] 		<- 0#
		}#
	}#
	# replace NAs#
	A %<>% as.data.frame#
	A[,c(#
		"Daily_Precip_mean",#
		"Daily_Precip_SD",#
		"Perc_Days_w_Rain",#
		"Perc_Days_w_Freeze",#
		"mean_Max_Temp",#
		"sd_Max_Temp",#
		"MeanDegreeDay",#
		"Mean_Consecutive_Days_w_Rain",#
		"Max_Consecutive_Days_w_Rain",#
		"sd_Consecutive_Days_w_Rain",#
		"Mean_Consecutive_Drought_Days",#
		"Max_Consecutive_Drought_Days",#
		"sd_Consecutive_Drought_Days",#
		"Mean_Consecutive_Freezing_Days",#
		"Max_Consecutive_Freezing_Days",#
		"sd_Consecutive_Freezing_Days")] %<>% #
		apply(., 2, NA_Function#
	)#
	A %<>% select(-PrevSurvD)#
	return(A)#
}
setwd('/Users/KSauby/Documents/Projects/dataproc/R')
calculateClimateVariables <- function(x, climate_data, calculate_dates="TRUE") {#
	climate_data %<>% renameLocations#
	# create list of dates#
	if (calculate_dates=="TRUE") {#
		# get unique Date and DaysSincePrevSurvey combos#
		A = as.data.frame(x) %>%#
			group_by(Date, Location, Species) %>%#
			# to make sure that this group all share the same Previous_Survey_Date Date#
			summarise(PrevSurvD = paste(Maximum(Previous_Survey_Date))) %>%#
			as.data.frame %>%#
			arrange(Location, Date)#
		#----------------- Fill in Missing Previous Survey Date for Survey 1 --##
		# Generate fake "PrevSurvD" based on the average number of days #
		#		between surveys#
		A$PrevSurvD[A$PrevSurvD=="NA" & year(A$Date)==2009] <- #
			as.character(A$Date[A$PrevSurvD=="NA" & year(A$Date)==2009] - #
			round(mean(x$DaysSincePrevSurvey, na.rm=T)))#
		A 			%<>% filter(PrevSurvD!="NA")#
		A$PrevSurvD %<>% as.Date("%Y-%m-%d")#
	} else {#
		A %<>% mutate(#
			# previous dates#
			PrevSurvD = as.Date(c(NA, Date[-length(Date)]), origin="1970-01-01")#
		)#
	}#
	# prep dataframe for addition of of climate variables#
	Names <- c(#
		"Daily_Precip_mean",#
		"Daily_Precip_SD",#
		"Perc_Days_w_Rain",#
		"Perc_Days_w_Freeze",#
		"mean_Max_Temp",#
		"sd_Max_Temp",#
		"MeanDegreeDay",#
		"Mean_Consecutive_Days_w_Rain",#
		"Max_Consecutive_Days_w_Rain",#
		"sd_Consecutive_Days_w_Rain",#
		"Mean_Consecutive_Drought_Days",#
		"Max_Consecutive_Drought_Days",#
		"sd_Consecutive_Drought_Days",#
		"Mean_Consecutive_Freezing_Days",#
		"Max_Consecutive_Freezing_Days",#
		"sd_Consecutive_Freezing_Days"#
	)#
	A1 <- A %>% cbind(#
		as.data.frame(#
			matrix(#
				nrow=dim(A)[1], #
				ncol=length(Names),#
				data=NA#
			)#
		)#
	)#
	names(A)[ ((dim(A)[2] + 1) : (dim(A)[2] + length(Names)) ] # <- Names#
	# for new plants, assign previous visit based on previous visit to location#
	# calculate climate variables#
	for (i in 1:dim(A)[1]) {#
		# subset data by time period and location#
		#		date is equal to or greater than previous survey date#
		temp = climate_data[which(#
			climate_data$Date >= A$PrevSurvD[i] & #
			climate_data$Date < A$Date[i] & # date is less than current date#
			climate_data$Location==A$Location[i]#
		), ] # and pull data for correct location #
		# Climate Variable Calculations#
		A$Daily_Precip_mean[i] 	<- mean(temp$Precip, na.rm=T)#
		A$Daily_Precip_SD[i] 	<- sd(temp$Precip, na.rm=T)#
		#		length of precip > 0 / length of precip != NA#
		A$Perc_Days_w_Rain[i] 	<- #
			length(filter(temp, Precip>0)$Precip) / length(!is.na(temp$Precip))#
		#		length of MinTemp <= 0 / length of MinTemp != NA#
		A$Perc_Days_w_Freeze[i] <- #
			length(filter(temp, MinTemp<=0)$MinTemp) / #
			length(!is.na(temp$MinTemp))#
		A$mean_Max_Temp[i] 		<- mean(temp$MaxTemp, na.rm=T)#
		A$sd_Max_Temp[i] 		<- sd(temp$MaxTemp, na.rm=T)#
		A$MeanDegreeDay[i] 		<- mean(temp$Daily.DD, na.rm=T)#
		# consecutive days with rain#
		# count identical consecutive values#
		r <- rle(temp$Precip_Presence)#
		# get lengths for value=1#
		r1 <- r$length[r$values == 1]#
		A$Mean_Consecutive_Days_w_Rain[i] 	<- mean(r1, na.rm=T)#
		A$Max_Consecutive_Days_w_Rain[i] 	<- max(r1, na.rm=T)#
		A$sd_Consecutive_Days_w_Rain[i] 	<- sd(r1, na.rm=T)#
		# consecutive drought days#
		r0 <- r$length[r$values == 0]#
		A$Mean_Consecutive_Drought_Days[i] 	<- mean(r0, na.rm=T)#
		A$Max_Consecutive_Drought_Days[i] 	<- max(r0, na.rm=T)#
		A$sd_Consecutive_Drought_Days[i] 	<- sd(r0, na.rm=T)#
		# Consecutive Freezing Days#
		# count identical consecutive values#
		r <- rle(temp$MinTemp_lt_equal_0)#
		# get lengths for value=1#
		r1 <- r$length[r$values == 1]#
		#	if there was at least one freezing day:#
		if (length(r1) > 0) {#
			A$Mean_Consecutive_Freezing_Days[i] 	<- mean(r1, na.rm=T)#
			A$Max_Consecutive_Freezing_Days[i] 		<- max(r1, na.rm=T)#
			# 	calculate sd if there is more than one value; otherwise sd=0#
			A$sd_Consecutive_Freezing_Days[i] 		<- ifelse(#
				length(r1)>1, #
				sd(r$length[r$values == 1], na.rm=T),#
				0#
			)#
		} else {#
			A$Mean_Consecutive_Freezing_Days[i] 	<- 0#
			A$Max_Consecutive_Freezing_Days[i] 		<- 0#
			A$sd_Consecutive_Freezing_Days[i] 		<- 0#
		}#
	}#
	# replace NAs#
	A %<>% as.data.frame#
	A[,c(#
		"Daily_Precip_mean",#
		"Daily_Precip_SD",#
		"Perc_Days_w_Rain",#
		"Perc_Days_w_Freeze",#
		"mean_Max_Temp",#
		"sd_Max_Temp",#
		"MeanDegreeDay",#
		"Mean_Consecutive_Days_w_Rain",#
		"Max_Consecutive_Days_w_Rain",#
		"sd_Consecutive_Days_w_Rain",#
		"Mean_Consecutive_Drought_Days",#
		"Max_Consecutive_Drought_Days",#
		"sd_Consecutive_Drought_Days",#
		"Mean_Consecutive_Freezing_Days",#
		"Max_Consecutive_Freezing_Days",#
		"sd_Consecutive_Freezing_Days")] %<>% #
		apply(., 2, NA_Function#
	)#
	A %<>% select(-PrevSurvD)#
	return(A)#
}
